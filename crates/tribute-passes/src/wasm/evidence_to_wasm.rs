//! Evidence runtime functions to WASM lowering.
//!
//! This pass transforms calls to evidence runtime functions into inline WASM operations:
//!
//! - `__tribute_evidence_lookup(ev, ability_id)` → inline array search + struct_get
//! - `__tribute_evidence_extend(ev, marker)` → inline array copy with insertion
//!
//! ## Evidence Structure
//!
//! Evidence is represented as a WasmGC array of Marker structs, sorted by ability_id:
//!
//! ```text
//! Evidence = Array(Marker)
//! Marker = struct { ability_id: i32, prompt_tag: i32, op_table_index: i32 }
//! ```
//!
//! ## Current Implementation
//!
//! Phase 1: Remove the runtime function declarations. The actual calls are kept
//! and will be implemented as WASM imports or inline code in a future phase.
//!
//! Phase 2 (TODO): Implement inline WASM operations for lookup and extend.

use trunk_ir::dialect::{core, func, wasm};
use trunk_ir::{Block, DialectOp, IdVec, Operation, Region, Symbol};

/// Lower evidence runtime function declarations.
///
/// Phase 1: Remove the stub function declarations for evidence runtime functions.
/// The actual function calls remain and will be handled by WASM imports.
///
/// This pass is applied during the WASM lowering pipeline to clean up the
/// evidence runtime function stubs that were generated by resolve_evidence.rs.
#[salsa::tracked]
pub fn lower_evidence_to_wasm<'db>(
    db: &'db dyn salsa::Database,
    module: core::Module<'db>,
) -> core::Module<'db> {
    let body = module.body(db);
    let blocks = body.blocks(db);

    let Some(entry_block) = blocks.first() else {
        return module;
    };

    let mut changed = false;
    let new_ops: IdVec<Operation<'db>> = entry_block
        .operations(db)
        .iter()
        .filter_map(|op| {
            // Remove evidence runtime function declarations (func.func stubs)
            if let Ok(func_op) = func::Func::from_operation(db, *op) {
                let name = func_op.sym_name(db);
                if name == Symbol::new("__tribute_evidence_lookup")
                    || name == Symbol::new("__tribute_evidence_extend")
                {
                    changed = true;
                    return None; // Remove the declaration
                }
            }

            // Also remove wasm.func stubs if they exist
            if let Ok(func_op) = wasm::Func::from_operation(db, *op) {
                let name = func_op.sym_name(db);
                if name == Symbol::new("__tribute_evidence_lookup")
                    || name == Symbol::new("__tribute_evidence_extend")
                {
                    changed = true;
                    return None; // Remove the declaration
                }
            }

            Some(*op)
        })
        .collect();

    if !changed {
        return module;
    }

    let new_entry_block = Block::new(
        db,
        entry_block.id(db),
        entry_block.location(db),
        entry_block.args(db).clone(),
        new_ops,
    );

    let new_body = Region::new(db, body.location(db), IdVec::from(vec![new_entry_block]));
    core::Module::create(db, module.location(db), module.name(db), new_body)
}

#[cfg(test)]
mod tests {
    use super::*;
    use salsa_test_macros::salsa_test;
    use trunk_ir::dialect::core;
    use trunk_ir::{BlockArg, BlockId, DialectType, Location, PathId, Span, idvec};

    fn test_location(db: &dyn salsa::Database) -> Location<'_> {
        let path = PathId::new(db, "test.trb".to_owned());
        Location::new(path, Span::new(0, 0))
    }

    #[salsa::tracked]
    fn make_evidence_lookup_module(db: &dyn salsa::Database) -> core::Module<'_> {
        let location = test_location(db);

        // Create a module with __tribute_evidence_lookup declaration
        let evidence_ty = wasm::Anyref::new(db).as_type();
        let i32_ty = core::I32::new(db).as_type();
        let marker_ty = wasm::Structref::new(db).as_type();

        let func_ty = core::Func::new(db, IdVec::from(vec![evidence_ty, i32_ty]), marker_ty);
        let unreachable_op = func::unreachable(db, location);
        let body_block = Block::new(
            db,
            BlockId::fresh(),
            location,
            IdVec::from(vec![
                BlockArg::of_type(db, evidence_ty),
                BlockArg::of_type(db, i32_ty),
            ]),
            IdVec::from(vec![unreachable_op.as_operation()]),
        );
        let body = Region::new(db, location, IdVec::from(vec![body_block]));
        let lookup_func = func::func(
            db,
            location,
            Symbol::new("__tribute_evidence_lookup"),
            *func_ty,
            body,
        );

        let entry_block = Block::new(
            db,
            BlockId::fresh(),
            location,
            idvec![],
            IdVec::from(vec![lookup_func.as_operation()]),
        );
        let module_body = Region::new(db, location, IdVec::from(vec![entry_block]));
        core::Module::create(db, location, "test".into(), module_body)
    }

    #[salsa_test]
    fn test_evidence_runtime_function_removal(db: &salsa::DatabaseImpl) {
        // Test that evidence runtime function declarations are removed
        let module = make_evidence_lookup_module(db);

        // Lower
        let lowered = lower_evidence_to_wasm(db, module);

        // Check that the function declaration was removed
        let new_body = lowered.body(db);
        let new_entry = new_body.blocks(db).first().unwrap();
        assert_eq!(
            new_entry.operations(db).len(),
            0,
            "Evidence runtime function should be removed"
        );
    }

    #[salsa::tracked]
    fn make_other_function_module(db: &dyn salsa::Database) -> core::Module<'_> {
        let location = test_location(db);

        // Create a module with a regular function
        let i32_ty = core::I32::new(db).as_type();
        let func_ty = core::Func::new(db, IdVec::new(), i32_ty);
        let unreachable_op = func::unreachable(db, location);
        let body_block = Block::new(
            db,
            BlockId::fresh(),
            location,
            idvec![],
            IdVec::from(vec![unreachable_op.as_operation()]),
        );
        let body = Region::new(db, location, IdVec::from(vec![body_block]));
        let other_func = func::func(db, location, Symbol::new("other_function"), *func_ty, body);

        let entry_block = Block::new(
            db,
            BlockId::fresh(),
            location,
            idvec![],
            IdVec::from(vec![other_func.as_operation()]),
        );
        let module_body = Region::new(db, location, IdVec::from(vec![entry_block]));
        core::Module::create(db, location, "test".into(), module_body)
    }

    #[salsa_test]
    fn test_other_functions_preserved(db: &salsa::DatabaseImpl) {
        // Test that non-evidence functions are preserved
        let module = make_other_function_module(db);

        // Lower
        let lowered = lower_evidence_to_wasm(db, module);

        // Check that the function was preserved
        let new_body = lowered.body(db);
        let new_entry = new_body.blocks(db).first().unwrap();
        assert_eq!(
            new_entry.operations(db).len(),
            1,
            "Other functions should be preserved"
        );
    }
}
