//! Reference counting insertion pass.
//!
//! Automatically inserts `tribute_rt.retain` and `tribute_rt.release` operations
//! for pointer-typed (`core.ptr`) values in the native backend pipeline.
//!
//! ## Pipeline Position
//!
//! Runs after Phase 2.7 (`tribute_rt_to_clif` boxing lowering), where:
//! - All allocations are `clif.call @__tribute_alloc`
//! - Boxing ops are already lowered to clif
//! - Pointer types are all `core.ptr`
//! - `tribute_rt.retain`/`release` are preserved as legal ops
//!
//! ## RC Rules
//!
//! ### Retain (reference acquisition)
//!
//! | Situation | Action |
//! |-----------|--------|
//! | Function parameter (ptr) | `retain` at entry |
//! | `clif.call @__tribute_alloc` result | No retain (starts with refcount=1) |
//! | Other `clif.call` result (ptr) | No retain (ownership transfer) |
//! | `clif.store` with ptr value | `retain` before store |
//! | `clif.load` with ptr result | `retain` after load |
//!
//! ### Release (reference drop)
//!
//! | Situation | Action |
//! |-----------|--------|
//! | Last SSA use in block | `release` after last use |
//! | `clif.return` operand | No release (ownership transfer to caller) |
//! | Value dies in block (live-in but not live-out) | `release` at appropriate point |

use std::collections::{HashMap, HashSet};

use tribute_ir::dialect::tribute_rt;
use trunk_ir::dialect::{clif, core};
use trunk_ir::{
    Block, BlockId, DialectOp, DialectType, IdVec, Operation, Region, Symbol, Type, Value, ValueDef,
};

/// Insert reference counting operations for all pointer-typed values.
///
/// This pass performs liveness analysis and inserts `tribute_rt.retain` and
/// `tribute_rt.release` operations to manage heap-allocated objects.
#[salsa::tracked]
pub fn insert_rc<'db>(
    db: &'db dyn salsa::Database,
    module: core::Module<'db>,
) -> core::Module<'db> {
    let body = module.body(db);
    let mut changed = false;

    let new_blocks: IdVec<Block<'db>> = body
        .blocks(db)
        .iter()
        .map(|top_op_block| {
            // Each top-level operation in the module body is a clif.func
            let new_ops: IdVec<Operation<'db>> = top_op_block
                .operations(db)
                .iter()
                .map(|op| {
                    if let Ok(func_op) = clif::Func::from_operation(db, *op) {
                        // Skip release functions generated by the RTTI pass —
                        // they already contain explicit tribute_rt.release ops.
                        let sym = func_op.sym_name(db);
                        if sym.with_str(|s| s.starts_with(super::rtti::RELEASE_FN_PREFIX)) {
                            return *op;
                        }

                        let func_body = func_op.body(db);
                        let new_body = insert_rc_in_function(db, &func_body);
                        if new_body != func_body {
                            changed = true;
                            op.modify(db).regions(IdVec::from(vec![new_body])).build()
                        } else {
                            *op
                        }
                    } else {
                        *op
                    }
                })
                .collect();

            if changed {
                Block::new(
                    db,
                    top_op_block.id(db),
                    top_op_block.location(db),
                    top_op_block.args(db).clone(),
                    new_ops,
                )
            } else {
                *top_op_block
            }
        })
        .collect();

    if !changed {
        return module;
    }

    let new_body = Region::new(db, body.location(db), new_blocks);
    core::Module::create(db, module.location(db), module.name(db), new_body)
}

/// Check if a type is `core.ptr`.
fn is_ptr_type(db: &dyn salsa::Database, ty: Type<'_>) -> bool {
    core::Ptr::from_type(db, ty).is_some()
}

/// Get the type of a Value.
fn value_type<'db>(
    db: &'db dyn salsa::Database,
    value: Value<'db>,
    block_arg_types: &HashMap<(BlockId, usize), Type<'db>>,
) -> Option<Type<'db>> {
    match value.def(db) {
        ValueDef::OpResult(op) => op.results(db).get(value.index(db)).copied(),
        ValueDef::BlockArg(block_id) => block_arg_types.get(&(block_id, value.index(db))).copied(),
    }
}

/// Check if a value is a pointer type.
fn is_ptr_value<'db>(
    db: &'db dyn salsa::Database,
    value: Value<'db>,
    block_arg_types: &HashMap<(BlockId, usize), Type<'db>>,
) -> bool {
    value_type(db, value, block_arg_types)
        .map(|ty| is_ptr_type(db, ty))
        .unwrap_or(false)
}

/// Check if an operation is `clif.return`.
fn is_return_op(db: &dyn salsa::Database, op: &Operation<'_>) -> bool {
    clif::Return::from_operation(db, *op).is_ok()
}

/// Check if an operation is a block terminator.
fn is_terminator_op(db: &dyn salsa::Database, op: &Operation<'_>) -> bool {
    // Use `matches` (dialect+name check) instead of `from_operation` to avoid
    // spurious failures when successor blocks are not yet attached.
    clif::Return::matches(db, *op)
        || clif::Jump::matches(db, *op)
        || clif::Brif::matches(db, *op)
        || clif::Trap::matches(db, *op)
        || clif::ReturnCall::matches(db, *op)
        || clif::BrTable::matches(db, *op)
}

/// Check if an operation is `clif.load`.
fn is_load_op(db: &dyn salsa::Database, op: &Operation<'_>) -> bool {
    clif::Load::from_operation(db, *op).is_ok()
}

// =============================================================================
// Liveness Analysis
// =============================================================================

/// Per-block liveness information for pointer values.
struct LivenessInfo<'db> {
    /// Values defined in this block.
    def_set: HashMap<BlockId, HashSet<Value<'db>>>,
    /// Values live at entry of this block.
    live_in: HashMap<BlockId, HashSet<Value<'db>>>,
    /// Values live at exit of this block.
    live_out: HashMap<BlockId, HashSet<Value<'db>>>,
}

/// Collect block argument types for all blocks in the function body.
fn collect_block_arg_types<'db>(
    db: &'db dyn salsa::Database,
    body: &Region<'db>,
) -> HashMap<(BlockId, usize), Type<'db>> {
    let mut types = HashMap::new();
    for block in body.blocks(db).iter() {
        let block_id = block.id(db);
        for (idx, arg) in block.args(db).iter().enumerate() {
            types.insert((block_id, idx), arg.ty(db));
        }
    }
    types
}

/// Collect the set of all pointer-typed values in the function.
fn collect_ptr_values<'db>(
    db: &'db dyn salsa::Database,
    body: &Region<'db>,
    block_arg_types: &HashMap<(BlockId, usize), Type<'db>>,
) -> HashSet<Value<'db>> {
    let mut ptr_values = HashSet::new();

    for block in body.blocks(db).iter() {
        let block_id = block.id(db);

        // Block arguments
        for (idx, arg) in block.args(db).iter().enumerate() {
            if is_ptr_type(db, arg.ty(db)) {
                let val = Value::new(db, ValueDef::BlockArg(block_id), idx);
                ptr_values.insert(val);
            }
        }

        // Operation results
        for op in block.operations(db).iter() {
            for (idx, ty) in op.results(db).iter().enumerate() {
                if is_ptr_type(db, *ty) {
                    let val = op.result(db, idx);
                    ptr_values.insert(val);
                }
            }
        }
    }

    // Also check operands (which might be from other blocks via block args)
    for block in body.blocks(db).iter() {
        for op in block.operations(db).iter() {
            for operand in op.operands(db).iter() {
                if is_ptr_value(db, *operand, block_arg_types) {
                    ptr_values.insert(*operand);
                }
            }
            // Successor block arguments are passed as operands of the terminator,
            // already captured above via op.operands(db)
        }
    }

    ptr_values
}

/// Build the CFG successor map: block_id → set of successor block_ids.
fn build_successor_map<'db>(
    db: &'db dyn salsa::Database,
    body: &Region<'db>,
) -> HashMap<BlockId, Vec<BlockId>> {
    let mut successors: HashMap<BlockId, Vec<BlockId>> = HashMap::new();

    for block in body.blocks(db).iter() {
        let block_id = block.id(db);
        let mut succs = Vec::new();

        // The last operation in a block is typically the terminator
        if let Some(last_op) = block.operations(db).iter().last() {
            for succ_block in last_op.successors(db).iter() {
                succs.push(succ_block.id(db));
            }
        }

        successors.insert(block_id, succs);
    }

    successors
}

/// Compute use and def sets for each block (only for ptr values).
fn compute_use_def_sets<'db>(
    db: &'db dyn salsa::Database,
    body: &Region<'db>,
    ptr_values: &HashSet<Value<'db>>,
) -> (
    HashMap<BlockId, HashSet<Value<'db>>>,
    HashMap<BlockId, HashSet<Value<'db>>>,
) {
    let mut use_sets: HashMap<BlockId, HashSet<Value<'db>>> = HashMap::new();
    let mut def_sets: HashMap<BlockId, HashSet<Value<'db>>> = HashMap::new();

    for block in body.blocks(db).iter() {
        let block_id = block.id(db);
        let mut uses = HashSet::new();
        let mut defs = HashSet::new();

        // Block arguments are definitions
        for (idx, arg) in block.args(db).iter().enumerate() {
            if is_ptr_type(db, arg.ty(db)) {
                let val = Value::new(db, ValueDef::BlockArg(block_id), idx);
                defs.insert(val);
            }
        }

        // Walk operations
        for op in block.operations(db).iter() {
            // Operands used before definition in this block → use set
            for operand in op.operands(db).iter() {
                if ptr_values.contains(operand) && !defs.contains(operand) {
                    uses.insert(*operand);
                }
            }

            // Results are definitions
            for (idx, ty) in op.results(db).iter().enumerate() {
                if is_ptr_type(db, *ty) {
                    let val = op.result(db, idx);
                    defs.insert(val);
                }
            }
        }

        use_sets.insert(block_id, uses);
        def_sets.insert(block_id, defs);
    }

    (use_sets, def_sets)
}

/// Compute liveness information using backward dataflow analysis.
///
/// Iterates to fixpoint:
/// - `live_out(B)` = union of `live_in(S)` for each successor S of B
/// - `live_in(B)` = `use(B)` ∪ (`live_out(B)` - `def(B)`)
fn compute_liveness<'db>(
    db: &'db dyn salsa::Database,
    body: &Region<'db>,
    ptr_values: &HashSet<Value<'db>>,
) -> LivenessInfo<'db> {
    let (use_sets, def_sets) = compute_use_def_sets(db, body, ptr_values);
    let successor_map = build_successor_map(db, body);

    let block_ids: Vec<BlockId> = body.blocks(db).iter().map(|b| b.id(db)).collect();

    let mut live_in: HashMap<BlockId, HashSet<Value<'db>>> = HashMap::new();
    let mut live_out: HashMap<BlockId, HashSet<Value<'db>>> = HashMap::new();

    // Initialize
    for &bid in &block_ids {
        live_in.insert(bid, HashSet::new());
        live_out.insert(bid, HashSet::new());
    }

    // Iterate to fixpoint
    let mut changed = true;
    while changed {
        changed = false;

        for &bid in block_ids.iter().rev() {
            // live_out(B) = union of live_in(S) for successors S
            let mut new_live_out = HashSet::new();
            if let Some(succs) = successor_map.get(&bid) {
                for succ_id in succs {
                    if let Some(succ_live_in) = live_in.get(succ_id) {
                        new_live_out.extend(succ_live_in.iter().copied());
                    }
                }
            }

            // live_in(B) = use(B) ∪ (live_out(B) - def(B))
            let use_b = use_sets.get(&bid).cloned().unwrap_or_default();
            let def_b = def_sets.get(&bid).cloned().unwrap_or_default();
            let mut new_live_in = use_b;
            for v in &new_live_out {
                if !def_b.contains(v) {
                    new_live_in.insert(*v);
                }
            }

            if new_live_in != *live_in.get(&bid).unwrap() {
                live_in.insert(bid, new_live_in);
                changed = true;
            }
            if new_live_out != *live_out.get(&bid).unwrap() {
                live_out.insert(bid, new_live_out);
                changed = true;
            }
        }
    }

    LivenessInfo {
        def_set: def_sets,
        live_in,
        live_out,
    }
}

// =============================================================================
// RC Insertion
// =============================================================================

/// Actions to insert at specific positions in a block.
#[derive(Default)]
struct InsertionPlan<'db> {
    /// Operations to insert before a given operation index.
    before: HashMap<usize, Vec<Operation<'db>>>,
    /// Operations to insert after a given operation index.
    after: HashMap<usize, Vec<Operation<'db>>>,
    /// Operations to insert at the very beginning of the block (after block args).
    at_start: Vec<Operation<'db>>,
}

/// Insert RC operations in a function body.
fn insert_rc_in_function<'db>(db: &'db dyn salsa::Database, body: &Region<'db>) -> Region<'db> {
    let block_arg_types = collect_block_arg_types(db, body);
    let ptr_values = collect_ptr_values(db, body, &block_arg_types);

    if ptr_values.is_empty() {
        return *body;
    }

    let liveness = compute_liveness(db, body, &ptr_values);

    let new_blocks: IdVec<Block<'db>> = body
        .blocks(db)
        .iter()
        .enumerate()
        .map(|(block_idx, block)| {
            insert_rc_in_block(
                db,
                block,
                block_idx == 0, // is_entry
                &ptr_values,
                &liveness,
                &block_arg_types,
            )
        })
        .collect();

    Region::new(db, body.location(db), new_blocks)
}

/// Infer the allocation size for a value by tracing its def chain.
///
/// If the value was produced by `clif.call @__tribute_alloc(%size)` and `%size`
/// is a `clif.iconst`, returns the constant value. Otherwise returns 0 (unknown).
fn infer_alloc_size(db: &dyn salsa::Database, value: Value<'_>) -> u64 {
    let ValueDef::OpResult(def_op) = value.def(db) else {
        return 0; // block arg — unknown
    };

    // Check if the defining op is `clif.call @__tribute_alloc`
    let Ok(call_op) = clif::Call::from_operation(db, def_op) else {
        // Could be an iadd identity from box_value — trace through it
        if let Ok(iadd_op) = clif::Iadd::from_operation(db, def_op) {
            return infer_alloc_size(db, iadd_op.lhs(db));
        }
        return 0;
    };

    let callee = call_op.callee(db);
    if callee != Symbol::new("__tribute_alloc") {
        return 0;
    }

    // The first argument to __tribute_alloc is the size
    let args = def_op.operands(db);
    let Some(&size_val) = args.first() else {
        return 0;
    };

    // Check if the size argument is a constant
    let ValueDef::OpResult(size_op) = size_val.def(db) else {
        return 0;
    };

    if let Ok(iconst_op) = clif::Iconst::from_operation(db, size_op) {
        return iconst_op.value(db) as u64;
    }

    0
}

/// Check if a value is an intermediate allocation pointer that should not be
/// released individually.
///
/// The ADT construction pattern (`adt_rc_header`) produces three pointer values:
/// 1. `raw_ptr` = `__tribute_alloc(size)` — RC header base
/// 2. `payload_ptr` = `iadd(raw_ptr, 8)` — points past the RC header
/// 3. `identity` = `iadd(payload_ptr, 0)` — the "real" result
///
/// Only the identity pointer (#3) should be RC-tracked. The raw_ptr's release
/// would compute `raw_ptr - 8` (before the allocation), and the payload_ptr's
/// release would double-free with the identity pointer's release.
fn is_alloc_intermediate(db: &dyn salsa::Database, value: Value<'_>) -> bool {
    let ValueDef::OpResult(def_op) = value.def(db) else {
        return false;
    };

    // Case 1: direct `__tribute_alloc` result
    if let Ok(call_op) = clif::Call::from_operation(db, def_op) {
        return call_op.callee(db) == Symbol::new("__tribute_alloc");
    }

    // Case 2: `iadd(alloc_result, offset)` where LHS is a direct alloc result
    // This covers the payload_ptr but NOT the identity (whose LHS is payload_ptr).
    if let Ok(iadd_op) = clif::Iadd::from_operation(db, def_op) {
        let lhs = iadd_op.lhs(db);
        let ValueDef::OpResult(lhs_op) = lhs.def(db) else {
            return false;
        };
        if let Ok(call_op) = clif::Call::from_operation(db, lhs_op) {
            return call_op.callee(db) == Symbol::new("__tribute_alloc");
        }
    }

    false
}

/// Insert RC operations in a single block.
fn insert_rc_in_block<'db>(
    db: &'db dyn salsa::Database,
    block: &Block<'db>,
    is_entry: bool,
    ptr_values: &HashSet<Value<'db>>,
    liveness: &LivenessInfo<'db>,
    block_arg_types: &HashMap<(BlockId, usize), Type<'db>>,
) -> Block<'db> {
    let block_id = block.id(db);
    let ops = block.operations(db);
    let location = block.location(db);
    let ptr_ty = core::Ptr::new(db).as_type();

    let live_in = liveness.live_in.get(&block_id).cloned().unwrap_or_default();
    let live_out = liveness
        .live_out
        .get(&block_id)
        .cloned()
        .unwrap_or_default();

    // Compute per-value last use index in this block
    let mut last_use_in_block: HashMap<Value<'db>, usize> = HashMap::new();
    for (op_idx, op) in ops.iter().enumerate() {
        for operand in op.operands(db).iter() {
            if ptr_values.contains(operand) {
                last_use_in_block.insert(*operand, op_idx);
            }
        }
    }

    // Collect values that are returned (should NOT be released)
    let mut returned_values: HashSet<Value<'db>> = HashSet::new();
    if let Some(last_op) = ops.iter().last()
        && is_return_op(db, last_op)
    {
        for operand in last_op.operands(db).iter() {
            if ptr_values.contains(operand) {
                returned_values.insert(*operand);
            }
        }
    }

    let mut plan = InsertionPlan::default();

    // --- Retain insertions ---

    // 1. Entry block: retain each ptr parameter
    if is_entry {
        for (idx, arg) in block.args(db).iter().enumerate() {
            if is_ptr_type(db, arg.ty(db)) {
                let arg_val = block.arg(db, idx);
                let retain_op = tribute_rt::retain(db, location, arg_val, ptr_ty);
                plan.at_start.push(retain_op.as_operation());
            }
        }
    }

    // 2. Retain before clif.store of ptr value, and retain after clif.load of ptr result
    for (op_idx, op) in ops.iter().enumerate() {
        // clif.store: if the stored value is a ptr, retain before store
        if let Ok(store_op) = clif::Store::from_operation(db, *op) {
            let stored_val = store_op.value(db);
            if is_ptr_value(db, stored_val, block_arg_types) {
                let retain_op = tribute_rt::retain(db, op.location(db), stored_val, ptr_ty);
                plan.before
                    .entry(op_idx)
                    .or_default()
                    .push(retain_op.as_operation());
            }
        }

        // clif.load: if the result is a ptr, retain after load
        if is_load_op(db, op)
            && let Some(&result_ty) = op.results(db).first()
            && is_ptr_type(db, result_ty)
        {
            let load_result = op.result(db, 0);
            let retain_op = tribute_rt::retain(db, op.location(db), load_result, ptr_ty);
            plan.after
                .entry(op_idx)
                .or_default()
                .push(retain_op.as_operation());
        }
    }

    let defs_in_block = liveness.def_set.get(&block_id).cloned().unwrap_or_default();

    // 3. Yield point handling: extra retain before yield, release after yield (resume path)
    //
    // When `clif.call @__tribute_yield` is encountered, any live RC pointers
    // need an extra retain to protect them during continuation capture, and
    // a corresponding release on the resume path. Additionally, the set of
    // live RC roots is communicated to the runtime via TLS.
    for (op_idx, op) in ops.iter().enumerate() {
        if !is_yield_call(db, op) {
            continue;
        }

        // Compute live RC pointers at the yield point.
        // A value is "live across yield" if it is:
        // - In live_in (defined before this block, still alive)
        // - Defined in this block before the yield and used after the yield
        //   OR is in live_out
        let live_across_yield: Vec<Value<'db>> = {
            let mut live: Vec<Value<'db>> = Vec::new();

            // live_in values that are still alive past the yield
            for v in &live_in {
                // Must be used after yield or in live_out
                if live_out.contains(v) || has_use_after(db, ops, op_idx, *v) {
                    live.push(*v);
                }
            }

            // Values defined before yield in this block
            for v in &defs_in_block {
                if live_out.contains(v) || has_use_after(db, ops, op_idx, *v) {
                    // Check it was defined before the yield
                    if is_defined_before(db, ops, op_idx, *v) {
                        // Skip if already added from live_in
                        if !live.contains(v) {
                            live.push(*v);
                        }
                    }
                }
            }

            // Sort for deterministic order
            live.sort_by_key(|v| match v.def(db) {
                ValueDef::BlockArg(_) => (0usize, v.index(db)),
                ValueDef::OpResult(def_op) => {
                    let pos = ops.iter().position(|o| *o == def_op).unwrap_or(usize::MAX);
                    (1 + pos, v.index(db))
                }
            });
            live
        };

        if live_across_yield.is_empty() {
            continue;
        }

        let i32_ty = core::I32::new(db).as_type();
        let i64_ty = core::I64::new(db).as_type();
        let nil_ty = core::Nil::new(db).as_type();
        let loc = op.location(db);

        // Before yield: retain each live ptr + set up RC roots in TLS
        let before_ops = plan.before.entry(op_idx).or_default();

        for v in &live_across_yield {
            let retain_op = tribute_rt::retain(db, loc, *v, ptr_ty);
            before_ops.push(retain_op.as_operation());
        }

        // Allocate stack space for the roots array and store pointers
        // We use a sequence of stores into stack-allocated memory.
        // Since we're at the IR level (before Cranelift lowering), we
        // represent this as: alloc array, store each root, call set_rc_roots.

        let roots_count = live_across_yield.len();
        // Each entry is 16 bytes: (ptr: 8 bytes, alloc_size: 8 bytes)
        let array_size = (roots_count * 16) as i64;

        // Allocate temporary array on heap.
        // Ownership transfers to __tribute_cont_wrap_from_tls (which frees it
        // after copying). On the resume path, the buffer is already freed by
        // the runtime, so no post-yield dealloc is needed.
        let alloc_size_const = clif::iconst(db, loc, i64_ty, array_size);
        before_ops.push(alloc_size_const.as_operation());

        let alloc_call = clif::call(
            db,
            loc,
            vec![alloc_size_const.result(db)],
            ptr_ty,
            Symbol::new("__tribute_alloc"),
        );
        before_ops.push(alloc_call.as_operation());
        let roots_ptr = alloc_call.result(db);

        // Store each (ptr, alloc_size) pair into the array
        for (i, v) in live_across_yield.iter().enumerate() {
            let offset = (i * 16) as i32;
            // Store the pointer
            let store_ptr = clif::store(db, loc, *v, roots_ptr, offset);
            before_ops.push(store_ptr.as_operation());
            // Store the alloc_size (compile-time inferred)
            let obj_alloc_size = infer_alloc_size(db, *v);
            let size_const = clif::iconst(db, loc, i64_ty, obj_alloc_size as i64);
            before_ops.push(size_const.as_operation());
            let store_size = clif::store(db, loc, size_const.result(db), roots_ptr, offset + 8);
            before_ops.push(store_size.as_operation());
        }

        // Call __tribute_yield_set_rc_roots(roots_ptr, count)
        let count_const = clif::iconst(db, loc, i32_ty, roots_count as i64);
        before_ops.push(count_const.as_operation());

        let set_roots_call = clif::call(
            db,
            loc,
            vec![roots_ptr, count_const.result(db)],
            nil_ty,
            Symbol::new("__tribute_yield_set_rc_roots"),
        );
        before_ops.push(set_roots_call.as_operation());

        // After yield (resume path): release each live ptr to cancel the extra retain.
        // No dealloc of the roots buffer here — on the resume path, the handler
        // already called __tribute_cont_wrap_from_tls which freed the buffer.
        // If the body resumes normally, the buffer was already consumed.
        let after_ops = plan.after.entry(op_idx).or_default();

        for v in &live_across_yield {
            let obj_alloc_size = infer_alloc_size(db, *v);
            let release_op = tribute_rt::release(db, loc, *v, obj_alloc_size);
            after_ops.push(release_op.as_operation());
        }
    }

    // --- Release insertions ---
    // For each ptr value that "dies" in this block:
    // - If it's in live_in but not in live_out → it dies here
    // - If it's defined in this block and not in live_out → it dies here

    // Collect all ptr values that die in this block
    let mut dying_values: HashSet<Value<'db>> = HashSet::new();

    // Values from live_in that are not in live_out
    for v in &live_in {
        if !live_out.contains(v) && !returned_values.contains(v) {
            dying_values.insert(*v);
        }
    }

    // Values defined in this block that are not in live_out
    for v in &defs_in_block {
        if !live_out.contains(v) && !returned_values.contains(v) {
            // Skip raw alloc results — the release code subtracts 8 from the pointer
            // to find the RC header, but the alloc result IS the header base. Releasing
            // it would read/write at `raw_ptr - 8` which is before the allocation.
            // The derived payload pointer (`raw_ptr + 8`) handles the release correctly.
            if is_alloc_intermediate(db, *v) {
                continue;
            }
            dying_values.insert(*v);
        }
    }

    // Sort dying values for deterministic release emission order
    let mut dying_sorted: Vec<Value<'db>> = dying_values.into_iter().collect();
    dying_sorted.sort_by_key(|v| match v.def(db) {
        ValueDef::BlockArg(_) => (0usize, v.index(db)),
        ValueDef::OpResult(def_op) => {
            let pos = ops
                .iter()
                .position(|op| *op == def_op)
                .unwrap_or(usize::MAX);
            (1 + pos, v.index(db))
        }
    });

    // For each dying value, determine where to insert the release
    for v in &dying_sorted {
        if let Some(&last_use_idx) = last_use_in_block.get(v) {
            // Release after last use
            // But if last use is in a return, skip (already handled above)
            let last_op = &ops[last_use_idx];
            if is_return_op(db, last_op) {
                continue;
            }
            let alloc_size = infer_alloc_size(db, *v);
            let release_op = tribute_rt::release(db, last_op.location(db), *v, alloc_size);
            // If the last use is a terminator (jump/brif), insert release BEFORE it
            // to avoid adding instructions after a block-ending operation.
            if is_terminator_op(db, last_op) {
                // clif.jump transfers all operands to the successor block
                // as block arguments — ownership transfers, no release needed.
                if clif::Jump::matches(db, *last_op) {
                    continue;
                }
                plan.before
                    .entry(last_use_idx)
                    .or_default()
                    .push(release_op.as_operation());
            } else {
                plan.after
                    .entry(last_use_idx)
                    .or_default()
                    .push(release_op.as_operation());
            }
        } else {
            // Value is not used in this block but is live-in → release at start
            if live_in.contains(v) {
                let alloc_size = infer_alloc_size(db, *v);
                let release_op = tribute_rt::release(db, location, *v, alloc_size);
                plan.at_start.push(release_op.as_operation());
            }
            // Value defined in this block but never used (dead allocation) → release after def
            else if let ValueDef::OpResult(def_op) = v.def(db) {
                // Find the op index
                for (op_idx, op) in ops.iter().enumerate() {
                    if *op == def_op {
                        let alloc_size = infer_alloc_size(db, *v);
                        let release_op = tribute_rt::release(db, op.location(db), *v, alloc_size);
                        plan.after
                            .entry(op_idx)
                            .or_default()
                            .push(release_op.as_operation());
                        break;
                    }
                }
            }
            // Unused block arg that is not live-out → release at block start
            else if let ValueDef::BlockArg(_) = v.def(db) {
                let alloc_size = infer_alloc_size(db, *v);
                let release_op = tribute_rt::release(db, location, *v, alloc_size);
                plan.at_start.push(release_op.as_operation());
            }
        }
    }

    // --- Reconstruct block ---
    apply_insertion_plan(db, block, &plan)
}

/// Check if an operation is `clif.call @__tribute_yield`.
fn is_yield_call(db: &dyn salsa::Database, op: &Operation<'_>) -> bool {
    if let Ok(call_op) = clif::Call::from_operation(db, *op) {
        call_op.callee(db) == Symbol::new("__tribute_yield")
    } else {
        false
    }
}

/// Check if a value has any use after the given operation index in the block.
fn has_use_after<'db>(
    db: &'db dyn salsa::Database,
    ops: &IdVec<Operation<'db>>,
    after_idx: usize,
    value: Value<'db>,
) -> bool {
    for op in ops.iter().skip(after_idx + 1) {
        for operand in op.operands(db).iter() {
            if *operand == value {
                return true;
            }
        }
    }
    false
}

/// Check if a value is defined before the given operation index in the block.
fn is_defined_before<'db>(
    db: &'db dyn salsa::Database,
    ops: &IdVec<Operation<'db>>,
    before_idx: usize,
    value: Value<'db>,
) -> bool {
    match value.def(db) {
        ValueDef::BlockArg(_) => true, // block args are always "before"
        ValueDef::OpResult(def_op) => {
            for (i, op) in ops.iter().enumerate() {
                if i >= before_idx {
                    return false;
                }
                if *op == def_op {
                    return true;
                }
            }
            false
        }
    }
}

/// Apply an insertion plan to a block, producing a new block with RC ops inserted.
fn apply_insertion_plan<'db>(
    db: &'db dyn salsa::Database,
    block: &Block<'db>,
    plan: &InsertionPlan<'db>,
) -> Block<'db> {
    let ops = block.operations(db);
    let has_changes =
        !plan.at_start.is_empty() || !plan.before.is_empty() || !plan.after.is_empty();

    if !has_changes {
        return *block;
    }

    let mut new_ops: Vec<Operation<'db>> = Vec::new();

    // Insert at_start operations
    new_ops.extend(plan.at_start.iter().copied());

    // Walk existing operations and insert before/after
    for (idx, op) in ops.iter().enumerate() {
        // Insert before
        if let Some(before_ops) = plan.before.get(&idx) {
            new_ops.extend(before_ops.iter().copied());
        }

        // Original operation
        new_ops.push(*op);

        // Insert after
        if let Some(after_ops) = plan.after.get(&idx) {
            new_ops.extend(after_ops.iter().copied());
        }
    }

    Block::new(
        db,
        block.id(db),
        block.location(db),
        block.args(db).clone(),
        new_ops.into_iter().collect(),
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use salsa_test_macros::salsa_test;
    use trunk_ir::parser::parse_test_module;
    use trunk_ir::printer::print_op;

    #[salsa::input]
    struct TextInput {
        #[returns(ref)]
        text: String,
    }

    #[salsa::tracked]
    fn do_insert_rc(db: &dyn salsa::Database, input: TextInput) -> core::Module<'_> {
        let module = parse_test_module(db, input.text(db));
        insert_rc(db, module)
    }

    fn run_rc(db: &salsa::DatabaseImpl, ir: &str) -> String {
        let input = TextInput::new(db, ir.to_string());
        let result = do_insert_rc(db, input);
        print_op(db, result.as_operation())
    }

    // === Tests ===

    #[salsa_test]
    fn test_ptr_param_retain_release(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.nil, core.ptr)} {
                    ^entry(%p: core.ptr):
                        clif.return %p
                }
            }
            "#,
        );

        // Parameter is returned → retain at entry, no release
        assert!(
            ir.contains("tribute_rt.retain"),
            "should retain ptr param: {ir}"
        );
        // Since %p is returned, it should NOT be released
        assert!(
            !ir.contains("tribute_rt.release"),
            "should not release returned ptr: {ir}"
        );
    }

    #[salsa_test]
    fn test_alloc_return_no_release(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.ptr)} {
                    ^entry():
                        %size = clif.iconst {value = 8} : core.i64
                        %ptr = clif.call %size {callee = @__tribute_alloc} : core.ptr
                        clif.return %ptr
                }
            }
            "#,
        );

        // Alloc result returned → no retain or release needed
        assert!(
            !ir.contains("tribute_rt.release"),
            "should not release returned alloc: {ir}"
        );
    }

    #[salsa_test]
    fn test_ptr_param_used_not_returned(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.i32, core.ptr)} {
                    ^entry(%p: core.ptr):
                        %val = clif.load %p {offset = 0} : core.i32
                        clif.return %val
                }
            }
            "#,
        );

        // ptr param is used (load) but not returned → retain at entry, release after last use
        assert!(
            ir.contains("tribute_rt.retain"),
            "should retain ptr param: {ir}"
        );
        assert!(
            ir.contains("tribute_rt.release"),
            "should release ptr param after last use: {ir}"
        );
    }

    #[salsa_test]
    fn test_store_ptr_retains(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.nil, core.ptr, core.ptr)} {
                    ^entry(%obj: core.ptr, %field_val: core.ptr):
                        clif.store %field_val, %obj {offset = 0}
                        clif.return
                }
            }
            "#,
        );

        // Should have retains for both params + extra retain before store
        let retain_count = ir.matches("tribute_rt.retain").count();
        // 2 param retains + 1 store retain = 3
        assert!(
            retain_count >= 3,
            "should have at least 3 retains (2 params + 1 store), got {retain_count}: {ir}"
        );
    }

    #[salsa_test]
    fn test_load_ptr_retains(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.ptr, core.ptr)} {
                    ^entry(%obj: core.ptr):
                        %field = clif.load %obj {offset = 8} : core.ptr
                        clif.return %field
                }
            }
            "#,
        );

        // Should retain param + retain after load
        let retain_count = ir.matches("tribute_rt.retain").count();
        assert!(
            retain_count >= 2,
            "should have at least 2 retains (param + load), got {retain_count}: {ir}"
        );
    }

    #[salsa_test]
    fn test_no_ptr_noop(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.i32, core.i32)} {
                    ^entry(%x: core.i32):
                        clif.return %x
                }
            }
            "#,
        );

        assert!(
            !ir.contains("tribute_rt.retain"),
            "should not insert retain for non-ptr: {ir}"
        );
        assert!(
            !ir.contains("tribute_rt.release"),
            "should not insert release for non-ptr: {ir}"
        );
    }

    #[salsa_test]
    fn test_unused_ptr_param_released(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.nil, core.ptr)} {
                    ^entry(%p: core.ptr):
                        clif.return
                }
            }
            "#,
        );

        // Unused ptr param → retain at entry + release at start (never used)
        assert!(
            ir.contains("tribute_rt.retain"),
            "should retain ptr param at entry: {ir}"
        );
        assert!(
            ir.contains("tribute_rt.release"),
            "should release unused ptr param: {ir}"
        );
    }

    // === Snapshot tests ===

    #[salsa_test]
    fn test_snapshot_simple_param(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @use_ptr {type = core.func(core.i32, core.ptr)} {
                    ^entry(%p: core.ptr):
                        %val = clif.load %p {offset = 0} : core.i32
                        clif.return %val
                }
            }
            "#,
        );
        insta::assert_snapshot!(ir);
    }

    #[salsa_test]
    fn test_release_order_deterministic(db: &salsa::DatabaseImpl) {
        // Multiple ptr params dying in the same block — release order must be stable
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.nil, core.ptr, core.ptr, core.ptr)} {
                    ^entry(%a: core.ptr, %b: core.ptr, %c: core.ptr):
                        clif.return
                }
            }
            "#,
        );

        // Run twice to verify determinism
        let ir2 = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.nil, core.ptr, core.ptr, core.ptr)} {
                    ^entry(%a: core.ptr, %b: core.ptr, %c: core.ptr):
                        clif.return
                }
            }
            "#,
        );
        assert_eq!(ir, ir2, "release order should be deterministic across runs");

        // 3 params → 3 retains + 3 releases
        let retain_count = ir.matches("tribute_rt.retain").count();
        let release_count = ir.matches("tribute_rt.release").count();
        assert_eq!(retain_count, 3, "should retain all 3 ptr params: {ir}");
        assert_eq!(release_count, 3, "should release all 3 ptr params: {ir}");
    }

    #[salsa_test]
    fn test_snapshot_alloc_store_return(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @alloc_and_store {type = core.func(core.ptr, core.i32)} {
                    ^entry(%val: core.i32):
                        %size = clif.iconst {value = 4} : core.i64
                        %ptr = clif.call %size {callee = @__tribute_alloc} : core.ptr
                        clif.store %val, %ptr {offset = 0}
                        clif.return %ptr
                }
            }
            "#,
        );
        insta::assert_snapshot!(ir);
    }

    #[salsa_test]
    fn test_snapshot_release_before_jump(db: &salsa::DatabaseImpl) {
        // ptr value passed as clif.jump operand — ownership transfers to successor block, no release
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @branch_with_ptr {type = core.func(core.nil, core.ptr)} {
                    ^entry(%p: core.ptr):
                        clif.jump %p
                    ^target(%q: core.ptr):
                        clif.return %q
                }
            }
            "#,
        );
        insta::assert_snapshot!(ir);
    }

    #[salsa_test]
    fn test_jump_multiple_ptr_operands_no_release(db: &salsa::DatabaseImpl) {
        // Multiple ptr operands passed via clif.jump — all transfer ownership, none released
        // in the source block. The successor block handles its own block args.
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.nil, core.ptr, core.ptr)} {
                    ^entry(%p: core.ptr, %q: core.ptr):
                        clif.jump %p, %q
                    ^target(%a: core.ptr, %b: core.ptr):
                        clif.return %a
                }
            }
            "#,
        );

        // Extract the source block (^bb1) content — no release should appear there
        let bb1_content = ir.split("^bb1").nth(1).unwrap();
        let bb1_content = bb1_content.split("^bb2").next().unwrap();
        assert!(
            !bb1_content.contains("tribute_rt.release"),
            "source block should not release jump operands: {ir}"
        );
    }

    #[salsa_test]
    fn test_brif_ptr_cond_still_released(db: &salsa::DatabaseImpl) {
        // clif.brif condition is consumed, not transferred — must still be released
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.nil, core.ptr)} {
                    ^entry(%p: core.ptr):
                        clif.brif %p
                    ^then():
                        clif.return
                    ^else():
                        clif.return
                }
            }
            "#,
        );

        assert!(
            ir.contains("tribute_rt.release"),
            "should release brif condition ptr: {ir}"
        );
    }

    // === Yield point tests ===

    #[salsa_test]
    fn test_yield_no_live_ptrs(db: &salsa::DatabaseImpl) {
        // yield with no live ptr values → no extra retain/release
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.ptr)} {
                    ^entry():
                        %tag = clif.iconst {value = 1} : core.i32
                        %op = clif.iconst {value = 0} : core.i32
                        %nul = clif.iconst {value = 0} : core.ptr
                        %res = clif.call %tag, %op, %nul {callee = @__tribute_yield} : core.ptr
                        clif.return %res
                }
            }
            "#,
        );

        // No ptr params, no live ptrs → no yield-related retain/release
        assert!(
            !ir.contains("tribute_rt.retain"),
            "no retain expected with no live ptrs: {ir}"
        );
        assert!(
            !ir.contains("__tribute_yield_set_rc_roots"),
            "no rc_roots setup expected with no live ptrs: {ir}"
        );
    }

    #[salsa_test]
    fn test_yield_one_live_ptr(db: &salsa::DatabaseImpl) {
        // yield with 1 live ptr → 1 extra retain before + 1 release after
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.ptr, core.ptr)} {
                    ^entry(%p: core.ptr):
                        %tag = clif.iconst {value = 1} : core.i32
                        %op = clif.iconst {value = 0} : core.i32
                        %res = clif.call %tag, %op, %p {callee = @__tribute_yield} : core.ptr
                        clif.return %p
                }
            }
            "#,
        );

        // Entry retain (param) + yield retain = at least 2 retains
        let retain_count = ir.matches("tribute_rt.retain").count();
        assert!(
            retain_count >= 2,
            "should have at least 2 retains (param + yield), got {retain_count}: {ir}"
        );

        // Should have __tribute_yield_set_rc_roots call
        assert!(
            ir.contains("__tribute_yield_set_rc_roots"),
            "should set RC roots before yield: {ir}"
        );

        // Post-yield dealloc is removed — buffer ownership transfers to
        // __tribute_cont_wrap_from_tls which frees it after copying.
        assert!(
            !ir.contains("__tribute_dealloc"),
            "should NOT dealloc roots array after yield (ownership transferred): {ir}"
        );
    }

    #[salsa_test]
    fn test_yield_multiple_live_ptrs(db: &salsa::DatabaseImpl) {
        // yield with 2 live ptrs → 2 extra retains + 2 extra releases
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.ptr, core.ptr, core.ptr)} {
                    ^entry(%a: core.ptr, %b: core.ptr):
                        %tag = clif.iconst {value = 1} : core.i32
                        %op = clif.iconst {value = 0} : core.i32
                        %res = clif.call %tag, %op, %a {callee = @__tribute_yield} : core.ptr
                        clif.return %b
                }
            }
            "#,
        );

        // Both %a and %b are live across the yield:
        // - %a is used as operand of yield AND %a is used before yield
        // - %b is returned after yield → live across yield
        // However %a's last use IS the yield call (as operand), so it is NOT live
        // across the yield (it doesn't need to survive past yield).
        // Only %b needs the extra retain (used after yield as return value).

        // Entry retains: 2 (for %a, %b)
        // Yield retains: 1 (for %b, which is live past the yield)
        // That said, %a is also still alive past yield if counted properly by
        // the liveness analysis. Let's just check the rc_roots setup exists.
        assert!(
            ir.contains("__tribute_yield_set_rc_roots"),
            "should set RC roots before yield: {ir}"
        );
    }

    #[salsa_test]
    fn test_yield_ptr_not_used_after(db: &salsa::DatabaseImpl) {
        // ptr used only before yield and not after → no extra retain for yield
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @f {type = core.func(core.ptr, core.ptr)} {
                    ^entry(%p: core.ptr):
                        %val = clif.load %p {offset = 0} : core.i32
                        %tag = clif.iconst {value = 1} : core.i32
                        %res = clif.call %tag, %val, %p {callee = @__tribute_yield} : core.ptr
                        clif.return %res
                }
            }
            "#,
        );

        // %p is used as operand in the yield call but not after it.
        // It's not in live_out and has no use after the yield.
        // So there should be NO extra yield-retain for %p.
        // (The entry retain and normal release still happen.)
        assert!(
            !ir.contains("__tribute_yield_set_rc_roots"),
            "no rc_roots setup when no ptr lives past yield: {ir}"
        );
    }

    #[salsa_test]
    fn test_snapshot_yield_with_live_ptr(db: &salsa::DatabaseImpl) {
        let ir = run_rc(
            db,
            r#"
            core.module @test {
                clif.func @yield_and_use {type = core.func(core.ptr, core.ptr)} {
                    ^entry(%p: core.ptr):
                        %tag = clif.iconst {value = 1} : core.i32
                        %op = clif.iconst {value = 0} : core.i32
                        %res = clif.call %tag, %op, %p {callee = @__tribute_yield} : core.ptr
                        clif.return %p
                }
            }
            "#,
        );
        insta::assert_snapshot!(ir);
    }
}
