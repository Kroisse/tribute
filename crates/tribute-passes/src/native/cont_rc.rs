//! Continuation RC rewrite pass.
//!
//! Rewrites handler dispatch code to use RC-safe continuation wrappers:
//!
//! 1. After `clif.call @__tribute_get_yield_continuation()`, inserts
//!    `clif.call @__tribute_cont_wrap_from_tls(k)` to wrap the raw resume
//!    pointer with captured RC roots from TLS.
//!
//! 2. Replaces `clif.call @__tribute_resume(k, val)` with
//!    `clif.call @__tribute_resume_safe(wrapped_k, val)`.
//!
//! 3. Replaces `clif.call @__tribute_resume_drop(k)` with
//!    `clif.call @__tribute_resume_drop_safe(wrapped_k)`.
//!
//! ## Pipeline Position
//!
//! Runs at Phase 2.85, after `insert_rc` (Phase 2.8) and before
//! `resolve_unrealized_casts` (Phase 3). At this point all calls are
//! `clif.call` operations.

use std::collections::HashMap;

use trunk_ir::dialect::{clif, core};
use trunk_ir::{Block, DialectOp, DialectType, IdVec, Operation, Region, Symbol, Value};

/// Rewrite continuation operations to use RC-safe wrappers.
///
/// This pass ensures that captured continuation stacks properly manage
/// RC-protected heap objects by wrapping raw resume pointers in
/// `TributeContinuation` structs that carry RC root metadata.
#[salsa::tracked]
pub fn rewrite_cont_rc<'db>(
    db: &'db dyn salsa::Database,
    module: core::Module<'db>,
) -> core::Module<'db> {
    let body = module.body(db);
    let mut changed = false;

    let new_blocks: IdVec<Block<'db>> = body
        .blocks(db)
        .iter()
        .map(|top_block| {
            let new_ops: IdVec<Operation<'db>> = top_block
                .operations(db)
                .iter()
                .map(|op| {
                    if let Ok(func_op) = clif::Func::from_operation(db, *op) {
                        let sym = func_op.sym_name(db);
                        // Skip release functions (generated by RTTI pass)
                        if sym.with_str(|s| s.starts_with(super::rtti::RELEASE_FN_PREFIX)) {
                            return *op;
                        }

                        let func_body = func_op.body(db);
                        let new_body = rewrite_region(db, &func_body);
                        if new_body != func_body {
                            changed = true;
                            op.modify(db).regions(IdVec::from(vec![new_body])).build()
                        } else {
                            *op
                        }
                    } else {
                        *op
                    }
                })
                .collect();

            if changed {
                Block::new(
                    db,
                    top_block.id(db),
                    top_block.location(db),
                    top_block.args(db).clone(),
                    new_ops,
                )
            } else {
                *top_block
            }
        })
        .collect();

    if !changed {
        return module;
    }

    let new_body = Region::new(db, body.location(db), new_blocks);
    core::Module::create(db, module.location(db), module.name(db), new_body)
}

/// Rewrite a region, processing all blocks.
fn rewrite_region<'db>(db: &'db dyn salsa::Database, region: &Region<'db>) -> Region<'db> {
    let mut changed = false;
    let new_blocks: IdVec<Block<'db>> = region
        .blocks(db)
        .iter()
        .map(|block| {
            let new_block = rewrite_block(db, block);
            if new_block != *block {
                changed = true;
            }
            new_block
        })
        .collect();

    if !changed {
        return *region;
    }

    Region::new(db, region.location(db), new_blocks)
}

/// Rewrite a single block's operations.
///
/// Scans for continuation-related calls and applies the three rewrites:
/// 1. Wrap `__tribute_get_yield_continuation` results
/// 2. Replace `__tribute_resume` with `__tribute_resume_safe`
/// 3. Replace `__tribute_resume_drop` with `__tribute_resume_drop_safe`
fn rewrite_block<'db>(db: &'db dyn salsa::Database, block: &Block<'db>) -> Block<'db> {
    let ops = block.operations(db);
    let mut new_ops: Vec<Operation<'db>> = Vec::with_capacity(ops.len() + 4);
    let mut value_remap: HashMap<Value<'db>, Value<'db>> = HashMap::new();
    let mut changed = false;

    let ptr_ty = core::Ptr::new(db).as_type();

    for op in ops.iter() {
        // First, remap operands of any operation if needed
        let op = remap_op_operands(db, op, &value_remap);

        // Also rewrite nested regions (e.g., inside scf.if that survived lowering)
        let op = rewrite_nested_regions(db, &op);

        if let Ok(call_op) = clif::Call::from_operation(db, op) {
            let callee = call_op.callee(db);

            if callee == Symbol::new("__tribute_get_yield_continuation") {
                // Keep the original call
                new_ops.push(op);
                let raw_k = op.result(db, 0);

                // Insert wrap call: %wrapped_k = clif.call @__tribute_cont_wrap_from_tls(%k)
                let wrap_call = clif::call(
                    db,
                    op.location(db),
                    vec![raw_k],
                    ptr_ty,
                    Symbol::new("__tribute_cont_wrap_from_tls"),
                );
                let wrapped_k = wrap_call.as_operation().result(db, 0);
                value_remap.insert(raw_k, wrapped_k);
                new_ops.push(wrap_call.as_operation());
                changed = true;
                continue;
            }

            if callee == Symbol::new("__tribute_resume") {
                // Replace callee: __tribute_resume → __tribute_resume_safe
                let new_call =
                    rebuild_call_with_callee(db, &op, Symbol::new("__tribute_resume_safe"));
                new_ops.push(new_call);
                changed = true;
                continue;
            }

            if callee == Symbol::new("__tribute_resume_drop") {
                // Replace callee: __tribute_resume_drop → __tribute_resume_drop_safe
                let new_call =
                    rebuild_call_with_callee(db, &op, Symbol::new("__tribute_resume_drop_safe"));
                new_ops.push(new_call);
                changed = true;
                continue;
            }
        }

        new_ops.push(op);
    }

    if !changed {
        return *block;
    }

    Block::new(
        db,
        block.id(db),
        block.location(db),
        block.args(db).clone(),
        IdVec::from(new_ops),
    )
}

/// Remap operands of an operation using the value remap table.
///
/// Returns the original operation if no operands need remapping.
fn remap_op_operands<'db>(
    db: &'db dyn salsa::Database,
    op: &Operation<'db>,
    remap: &HashMap<Value<'db>, Value<'db>>,
) -> Operation<'db> {
    if remap.is_empty() {
        return *op;
    }

    let operands = op.operands(db);
    let mut needs_remap = false;
    let new_operands: IdVec<Value<'db>> = operands
        .iter()
        .map(|v| {
            if let Some(new_v) = remap.get(v) {
                needs_remap = true;
                *new_v
            } else {
                *v
            }
        })
        .collect();

    if !needs_remap {
        return *op;
    }

    op.modify(db).operands(new_operands).build()
}

/// Rewrite nested regions of an operation (recursive descent).
///
/// Returns the original operation if no nested regions changed.
fn rewrite_nested_regions<'db>(
    db: &'db dyn salsa::Database,
    op: &Operation<'db>,
) -> Operation<'db> {
    let regions = op.regions(db);
    if regions.is_empty() {
        return *op;
    }

    let mut changed = false;
    let new_regions: IdVec<Region<'db>> = regions
        .iter()
        .map(|region| {
            let new_region = rewrite_region(db, region);
            if new_region != *region {
                changed = true;
            }
            new_region
        })
        .collect();

    if !changed {
        return *op;
    }

    op.modify(db).regions(new_regions).build()
}

/// Rebuild a `clif.call` operation with a different callee symbol.
///
/// Preserves all operands, results, and location.
fn rebuild_call_with_callee<'db>(
    db: &'db dyn salsa::Database,
    op: &Operation<'db>,
    new_callee: Symbol,
) -> Operation<'db> {
    use trunk_ir::Attribute;

    let mut attrs = op.attributes(db).clone();
    attrs.insert(Symbol::new("callee"), Attribute::Symbol(new_callee));
    op.modify(db).attrs(attrs).build()
}

#[cfg(test)]
mod tests {
    use super::*;
    use salsa_test_macros::salsa_test;
    use trunk_ir::parser::parse_test_module;
    use trunk_ir::printer::print_op;

    #[salsa::input]
    struct TextInput {
        #[returns(ref)]
        text: String,
    }

    #[salsa::tracked]
    fn do_rewrite(db: &dyn salsa::Database, input: TextInput) -> core::Module<'_> {
        let module = parse_test_module(db, input.text(db));
        rewrite_cont_rc(db, module)
    }

    fn run_rewrite(db: &salsa::DatabaseImpl, ir: &str) -> String {
        let input = TextInput::new(db, ir.to_string());
        let result = do_rewrite(db, input);
        print_op(db, result.as_operation())
    }

    #[salsa_test]
    fn test_no_continuation_ops_unchanged(db: &salsa::DatabaseImpl) {
        let ir = run_rewrite(
            db,
            r#"
            core.module @test {
                clif.func @no_cont {type = core.func(core.ptr)} {
                    ^entry():
                        %size = clif.iconst {value = 8} : core.i64
                        %ptr = clif.call %size {callee = @__tribute_alloc} : core.ptr
                        clif.return %ptr
                }
            }
            "#,
        );

        // No continuation ops → should not contain wrap or safe variants
        assert!(
            !ir.contains("__tribute_cont_wrap_from_tls"),
            "should not insert wrap when no continuation ops: {ir}"
        );
        assert!(
            !ir.contains("__tribute_resume_safe"),
            "should not have resume_safe: {ir}"
        );
    }

    #[salsa_test]
    fn test_get_yield_continuation_wrapped(db: &salsa::DatabaseImpl) {
        let ir = run_rewrite(
            db,
            r#"
            core.module @test {
                clif.func @handler {type = core.func(core.ptr)} {
                    ^entry():
                        %k = clif.call {callee = @__tribute_get_yield_continuation} : core.ptr
                        %v = clif.call {callee = @__tribute_get_yield_shift_value} : core.ptr
                        %r = clif.call %k, %v {callee = @__tribute_resume} : core.ptr
                        clif.return %r
                }
            }
            "#,
        );

        // Should wrap k after get_yield_continuation
        assert!(
            ir.contains("__tribute_cont_wrap_from_tls"),
            "should insert cont_wrap_from_tls: {ir}"
        );
        // Should replace resume with resume_safe
        assert!(
            ir.contains("__tribute_resume_safe"),
            "should rewrite resume to resume_safe: {ir}"
        );
        assert!(
            !ir.contains("callee = @__tribute_resume}"),
            "original resume should be replaced: {ir}"
        );
    }

    #[salsa_test]
    fn test_resume_drop_replaced(db: &salsa::DatabaseImpl) {
        let ir = run_rewrite(
            db,
            r#"
            core.module @test {
                clif.func @handler_drop {type = core.func(core.nil)} {
                    ^entry():
                        %k = clif.call {callee = @__tribute_get_yield_continuation} : core.ptr
                        clif.call %k {callee = @__tribute_resume_drop} : core.nil
                        clif.return
                }
            }
            "#,
        );

        // Should wrap k
        assert!(
            ir.contains("__tribute_cont_wrap_from_tls"),
            "should wrap continuation: {ir}"
        );
        // Should replace resume_drop with resume_drop_safe
        assert!(
            ir.contains("__tribute_resume_drop_safe"),
            "should rewrite resume_drop to resume_drop_safe: {ir}"
        );
        assert!(
            !ir.contains("callee = @__tribute_resume_drop}"),
            "original resume_drop should be replaced: {ir}"
        );
    }

    #[salsa_test]
    fn test_resume_without_get_continuation_still_replaced(db: &salsa::DatabaseImpl) {
        // __tribute_resume in a block where k comes from a block argument
        // (no get_yield_continuation in the same block). Callee should still
        // be replaced; no wrap is inserted.
        let ir = run_rewrite(
            db,
            r#"
            core.module @test {
                clif.func @arm {type = core.func(core.ptr, core.ptr, core.ptr)} {
                    ^entry(%k: core.ptr, %v: core.ptr):
                        %r = clif.call %k, %v {callee = @__tribute_resume} : core.ptr
                        clif.return %r
                }
            }
            "#,
        );

        assert!(
            ir.contains("__tribute_resume_safe"),
            "resume should be replaced even without get_yield_continuation: {ir}"
        );
        assert!(
            !ir.contains("__tribute_cont_wrap_from_tls"),
            "no wrap needed when k is a block arg: {ir}"
        );
    }
}
