//! Continuation RC rewrite pass.
//!
//! Wraps raw resume pointers with RC root metadata by inserting
//! `clif.call @__tribute_cont_wrap_from_tls(k)` after each
//! `clif.call @__tribute_get_yield_continuation()`.
//!
//! The wrapped pointer (`TributeContinuation*`) is then used by the
//! existing `__tribute_resume` / `__tribute_resume_drop` calls, which
//! expect wrapped continuations.
//!
//! ## Pipeline Position
//!
//! Runs at Phase 2.85, after `insert_rc` (Phase 2.8) and before
//! `resolve_unrealized_casts` (Phase 3). At this point all calls are
//! `clif.call` operations.

use std::collections::{HashMap, HashSet};

use tribute_ir::dialect::tribute_rt;
use trunk_ir::dialect::{clif, core};
use trunk_ir::{Block, DialectOp, DialectType, IdVec, Operation, Region, Symbol, Value};

/// Rewrite continuation operations to use RC-safe wrappers.
///
/// This pass ensures that captured continuation stacks properly manage
/// RC-protected heap objects by wrapping raw resume pointers in
/// `TributeContinuation` structs that carry RC root metadata.
#[salsa::tracked]
pub fn rewrite_cont_rc<'db>(
    db: &'db dyn salsa::Database,
    module: core::Module<'db>,
) -> core::Module<'db> {
    let body = module.body(db);
    let mut changed = false;

    let new_blocks: IdVec<Block<'db>> = body
        .blocks(db)
        .iter()
        .map(|top_block| {
            let new_ops: IdVec<Operation<'db>> = top_block
                .operations(db)
                .iter()
                .map(|op| {
                    if let Ok(func_op) = clif::Func::from_operation(db, *op) {
                        let sym = func_op.sym_name(db);
                        // Skip release functions (generated by RTTI pass)
                        if sym.with_str(|s| s.starts_with(super::rtti::RELEASE_FN_PREFIX)) {
                            return *op;
                        }

                        let func_body = func_op.body(db);
                        let new_body = rewrite_region(db, &func_body);
                        if new_body != func_body {
                            changed = true;
                            op.modify(db).regions(IdVec::from(vec![new_body])).build()
                        } else {
                            *op
                        }
                    } else {
                        *op
                    }
                })
                .collect();

            if changed {
                Block::new(
                    db,
                    top_block.id(db),
                    top_block.location(db),
                    top_block.args(db).clone(),
                    new_ops,
                )
            } else {
                *top_block
            }
        })
        .collect();

    if !changed {
        return module;
    }

    let new_body = Region::new(db, body.location(db), new_blocks);
    core::Module::create(db, module.location(db), module.name(db), new_body)
}

/// Rewrite a region, processing all blocks.
///
/// The `value_remap` and `cont_values` are shared across all blocks in the
/// region so that a continuation wrapped in one block is correctly remapped
/// when used in a different block (cross-block SSA references).
fn rewrite_region<'db>(db: &'db dyn salsa::Database, region: &Region<'db>) -> Region<'db> {
    let mut value_remap: HashMap<Value<'db>, Value<'db>> = HashMap::new();
    let mut cont_values: HashSet<Value<'db>> = HashSet::new();
    let mut changed = false;

    let new_blocks: IdVec<Block<'db>> = region
        .blocks(db)
        .iter()
        .map(|block| {
            let new_block = rewrite_block(db, block, &mut value_remap, &mut cont_values);
            if new_block != *block {
                changed = true;
            }
            new_block
        })
        .collect();

    if !changed {
        return *region;
    }

    Region::new(db, region.location(db), new_blocks)
}

/// Rewrite a single block's operations.
///
/// Scans for `__tribute_get_yield_continuation` calls and inserts
/// `__tribute_cont_wrap_from_tls` to wrap the raw resume pointer.
///
/// Also removes `tribute_rt.retain` / `tribute_rt.release` operations
/// that target wrapped continuation pointers, since those pointers are
/// `Box`-allocated by the runtime and do **not** have an RC header.
///
/// `value_remap` and `cont_values` are shared across all blocks in the
/// parent region, so remaps from earlier blocks apply to later ones.
fn rewrite_block<'db>(
    db: &'db dyn salsa::Database,
    block: &Block<'db>,
    value_remap: &mut HashMap<Value<'db>, Value<'db>>,
    cont_values: &mut HashSet<Value<'db>>,
) -> Block<'db> {
    let ops = block.operations(db);
    let mut new_ops: Vec<Operation<'db>> = Vec::with_capacity(ops.len() + 4);
    let mut changed = false;

    let ptr_ty = core::Ptr::new(db).as_type();

    for op in ops.iter() {
        // First, remap operands of any operation if needed
        let remapped = remap_op_operands(db, op, value_remap);
        if remapped != *op {
            changed = true;
        }

        // Also rewrite nested regions (e.g., inside scf.if that survived lowering)
        let op = rewrite_nested_regions(db, &remapped);

        if let Ok(call_op) = clif::Call::from_operation(db, op) {
            let callee = call_op.callee(db);

            if callee == Symbol::new("__tribute_get_yield_continuation") {
                // Keep the original call
                new_ops.push(op);
                let raw_k = op.result(db, 0);

                // Insert wrap call: %wrapped_k = clif.call @__tribute_cont_wrap_from_tls(%k)
                let wrap_call = clif::call(
                    db,
                    op.location(db),
                    vec![raw_k],
                    ptr_ty,
                    Symbol::new("__tribute_cont_wrap_from_tls"),
                );
                let wrapped_k = wrap_call.as_operation().result(db, 0);
                value_remap.insert(raw_k, wrapped_k);
                cont_values.insert(wrapped_k);
                new_ops.push(wrap_call.as_operation());
                changed = true;
                continue;
            }
        }

        // Remove retain/release on wrapped continuation pointers.
        // These pointers are Box-allocated by the runtime (no RC header).
        if let Ok(retain_op) = tribute_rt::Retain::from_operation(db, op) {
            let ptr = retain_op.ptr(db);
            if cont_values.contains(&ptr) {
                // Retain returns the same pointer — remap result to input
                let result = op.result(db, 0);
                value_remap.insert(result, ptr);
                changed = true;
                continue;
            }
        }
        if let Ok(release_op) = tribute_rt::Release::from_operation(db, op) {
            let ptr = release_op.ptr(db);
            if cont_values.contains(&ptr) {
                // Simply drop the release — no cleanup needed for Box ptrs
                changed = true;
                continue;
            }
        }

        new_ops.push(op);
    }

    if !changed {
        return *block;
    }

    Block::new(
        db,
        block.id(db),
        block.location(db),
        block.args(db).clone(),
        IdVec::from(new_ops),
    )
}

/// Remap operands of an operation using the value remap table.
///
/// Returns the original operation if no operands need remapping.
fn remap_op_operands<'db>(
    db: &'db dyn salsa::Database,
    op: &Operation<'db>,
    remap: &HashMap<Value<'db>, Value<'db>>,
) -> Operation<'db> {
    if remap.is_empty() {
        return *op;
    }

    let operands = op.operands(db);
    let mut needs_remap = false;
    let new_operands: IdVec<Value<'db>> = operands
        .iter()
        .map(|v| {
            if let Some(new_v) = remap.get(v) {
                needs_remap = true;
                *new_v
            } else {
                *v
            }
        })
        .collect();

    if !needs_remap {
        return *op;
    }

    op.modify(db).operands(new_operands).build()
}

/// Rewrite nested regions of an operation (recursive descent).
///
/// Returns the original operation if no nested regions changed.
fn rewrite_nested_regions<'db>(
    db: &'db dyn salsa::Database,
    op: &Operation<'db>,
) -> Operation<'db> {
    let regions = op.regions(db);
    if regions.is_empty() {
        return *op;
    }

    let mut changed = false;
    let new_regions: IdVec<Region<'db>> = regions
        .iter()
        .map(|region| {
            let new_region = rewrite_region(db, region);
            if new_region != *region {
                changed = true;
            }
            new_region
        })
        .collect();

    if !changed {
        return *op;
    }

    op.modify(db).regions(new_regions).build()
}

// ============================================================================
// Arena IR version
// ============================================================================

use trunk_ir::arena::TypeDataBuilder;
use trunk_ir::arena::context::IrContext;
use trunk_ir::arena::dialect::clif as arena_clif;
use trunk_ir::arena::ops::ArenaDialectOp;
use trunk_ir::arena::rewrite::ArenaModule;
use trunk_ir::arena::rewrite::helpers::erase_op;
use trunk_ir::arena::{BlockRef, OpRef, RegionRef, ValueRef};

use tribute_ir::arena::dialect::tribute_rt as arena_tribute_rt;

/// Arena: Rewrite continuation operations to use RC-safe wrappers.
pub fn rewrite_cont_rc_arena(ctx: &mut IrContext, module: ArenaModule) {
    let Some(first_block) = module.first_block(ctx) else {
        return;
    };
    let module_ops: Vec<OpRef> = ctx.block(first_block).ops.to_vec();

    for op in module_ops {
        if let Ok(func_op) = arena_clif::Func::from_op(ctx, op) {
            let sym = func_op.sym_name(ctx);
            if sym.with_str(|s| s.starts_with(super::rtti::RELEASE_FN_PREFIX)) {
                continue;
            }
            let body = func_op.body(ctx);
            rewrite_region_arena(ctx, body);
        }
    }
}

fn rewrite_region_arena(ctx: &mut IrContext, region: RegionRef) {
    let mut cont_values: HashSet<ValueRef> = HashSet::new();

    let blocks: Vec<BlockRef> = ctx.region(region).blocks.to_vec();
    for block in blocks {
        rewrite_block_arena(ctx, block, &mut cont_values);
    }
}

fn rewrite_block_arena(ctx: &mut IrContext, block: BlockRef, cont_values: &mut HashSet<ValueRef>) {
    let ptr_ty = ctx
        .types
        .intern(TypeDataBuilder::new(Symbol::new("core"), Symbol::new("ptr")).build());

    let ops: Vec<OpRef> = ctx.block(block).ops.to_vec();
    let mut ops_to_erase: Vec<OpRef> = Vec::new();

    for (idx, &op) in ops.iter().enumerate() {
        // Rewrite nested regions first
        let regions: Vec<RegionRef> = ctx.op(op).regions.to_vec();
        for region in regions {
            rewrite_region_arena(ctx, region);
        }

        // Check for clif.call operations
        if let Ok(call_op) = arena_clif::Call::from_op(ctx, op) {
            let callee = call_op.callee(ctx);

            if callee == Symbol::new("__tribute_get_yield_continuation") {
                let raw_k = ctx.op_result(op, 0);

                // Insert wrap call after this op
                let wrap_call = arena_clif::call(
                    ctx,
                    ctx.op(op).location,
                    [raw_k],
                    ptr_ty,
                    Symbol::new("__tribute_cont_wrap_from_tls"),
                );
                let wrapped_k = wrap_call.result(ctx);
                let wrap_op = wrap_call.op_ref();

                // Insert wrap_call into block after the current op
                if idx + 1 < ops.len() {
                    ctx.insert_op_before(block, ops[idx + 1], wrap_op);
                } else {
                    ctx.push_op(block, wrap_op);
                }

                // Replace all uses of raw_k with wrapped_k, then fix wrap_call
                ctx.replace_all_uses(raw_k, wrapped_k);
                ctx.set_op_operand(wrap_op, 0, raw_k);

                cont_values.insert(wrapped_k);
                continue;
            }
        }

        // Remove retain on wrapped continuation pointers
        if let Ok(_retain_op) = arena_tribute_rt::Retain::from_op(ctx, op) {
            let operands = ctx.op_operands(op).to_vec();
            let ptr = operands[0];
            if cont_values.contains(&ptr) {
                let result = ctx.op_result(op, 0);
                ctx.replace_all_uses(result, ptr);
                ops_to_erase.push(op);
                continue;
            }
        }

        // Remove release on wrapped continuation pointers
        if let Ok(_release_op) = arena_tribute_rt::Release::from_op(ctx, op) {
            let operands = ctx.op_operands(op).to_vec();
            let ptr = operands[0];
            if cont_values.contains(&ptr) {
                ops_to_erase.push(op);
                continue;
            }
        }
    }

    for op in ops_to_erase {
        erase_op(ctx, op);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use salsa_test_macros::salsa_test;
    use trunk_ir::parser::parse_test_module;
    use trunk_ir::printer::print_op;

    #[salsa::input]
    struct TextInput {
        #[returns(ref)]
        text: String,
    }

    #[salsa::tracked]
    fn do_rewrite(db: &dyn salsa::Database, input: TextInput) -> core::Module<'_> {
        let module = parse_test_module(db, input.text(db));
        rewrite_cont_rc(db, module)
    }

    fn run_rewrite(db: &salsa::DatabaseImpl, ir: &str) -> String {
        let input = TextInput::new(db, ir.to_string());
        let result = do_rewrite(db, input);
        print_op(db, result.as_operation())
    }

    #[salsa_test]
    fn test_no_continuation_ops_unchanged(db: &salsa::DatabaseImpl) {
        let ir = run_rewrite(
            db,
            r#"
            core.module @test {
                clif.func @no_cont {type = core.func(core.ptr)} {
                    ^entry():
                        %size = clif.iconst {value = 8} : core.i64
                        %ptr = clif.call %size {callee = @__tribute_alloc} : core.ptr
                        clif.return %ptr
                }
            }
            "#,
        );

        // No continuation ops → should not contain wrap or safe variants
        assert!(
            !ir.contains("__tribute_cont_wrap_from_tls"),
            "should not insert wrap when no continuation ops: {ir}"
        );
        assert!(
            !ir.contains("__tribute_resume_safe"),
            "should not have resume_safe: {ir}"
        );
    }

    #[salsa_test]
    fn test_get_yield_continuation_wrapped(db: &salsa::DatabaseImpl) {
        let ir = run_rewrite(
            db,
            r#"
            core.module @test {
                clif.func @handler {type = core.func(core.ptr)} {
                    ^entry():
                        %k = clif.call {callee = @__tribute_get_yield_continuation} : core.ptr
                        %v = clif.call {callee = @__tribute_get_yield_shift_value} : core.ptr
                        %r = clif.call %k, %v {callee = @__tribute_resume} : core.ptr
                        clif.return %r
                }
            }
            "#,
        );

        // Should wrap k after get_yield_continuation
        assert!(
            ir.contains("__tribute_cont_wrap_from_tls"),
            "should insert cont_wrap_from_tls: {ir}"
        );
        // __tribute_resume callee should be unchanged (it now expects wrapped pointers)
        assert!(
            ir.contains("callee = @__tribute_resume}"),
            "resume callee should remain unchanged: {ir}"
        );
    }

    #[salsa_test]
    fn test_resume_drop_with_wrapped_continuation(db: &salsa::DatabaseImpl) {
        let ir = run_rewrite(
            db,
            r#"
            core.module @test {
                clif.func @handler_drop {type = core.func(core.nil)} {
                    ^entry():
                        %k = clif.call {callee = @__tribute_get_yield_continuation} : core.ptr
                        clif.call %k {callee = @__tribute_resume_drop} : core.nil
                        clif.return
                }
            }
            "#,
        );

        // Should wrap k
        assert!(
            ir.contains("__tribute_cont_wrap_from_tls"),
            "should wrap continuation: {ir}"
        );
        // __tribute_resume_drop callee should be unchanged
        assert!(
            ir.contains("callee = @__tribute_resume_drop}"),
            "resume_drop callee should remain unchanged: {ir}"
        );
    }
}
