// Result Examples
// Demonstrates the Result type for operations that may fail

// Result type definition
enum Result(a, e) {
    Ok(a),
    Error(e)
}

// A function that may fail (simulating parsing)
fn parse_value(code: Int) -> Result(Int, Int) {
    case code {
        0 -> Ok(0)
        1 -> Ok(100)
        2 -> Ok(200)
        42 -> Ok(4200)
        _ -> Error(-1)  // -1 indicates parse error
    }
}

// Pattern matching on Result
fn handle_result(code: Int) -> Int {
    case parse_value(code) {
        Ok(n) -> n
        Error(e) -> e
    }
}

// Division that may fail
fn divide(a: Int, b: Int) -> Result(Int, Int) {
    case b {
        0 -> Error(-2)  // -2 indicates division by zero
        _ -> Ok(a / b)
    }
}

// Get value or use default
fn safe_parse(code: Int) -> Int {
    case parse_value(code) {
        Ok(n) -> n
        Error(_) -> 0
    }
}

// Check if parsing succeeded
fn is_valid(code: Int) -> Bool {
    case parse_value(code) {
        Ok(_) -> True
        Error(_) -> False
    }
}

// Chain two operations using nested pattern matching
fn parse_and_divide(num_code: Int, denom_code: Int) -> Result(Int, Int) {
    case parse_value(num_code) {
        Error(e) -> Error(e)
        Ok(n) -> {
            case parse_value(denom_code) {
                Error(e) -> Error(e)
                Ok(d) -> divide(n, d)
            }
        }
    }
}

// Main demonstration
fn main() -> Nil {
    let success = parse_value(42)         // Ok(4200)
    let failure = parse_value(999)        // Error(-1)

    let handled = handle_result(42)       // 4200
    let handled_err = handle_result(999)  // -1

    let safe = safe_parse(42)             // 4200
    let safe_default = safe_parse(999)    // 0

    let valid = is_valid(42)              // True
    let invalid = is_valid(999)           // False

    let division = parse_and_divide(1, 2) // Ok(50) - 100 / 200 = 0 (integer div)

    Nil
}
