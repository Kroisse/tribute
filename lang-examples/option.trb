// Option Examples
// Demonstrates the Option type for representing optional values

// Option type definition
enum Option(a) {
    None,
    Some(a)
}

// A function that may or may not return a value
fn find_value(id: Int) -> Option(Int) {
    case id {
        1 -> Some(100)
        2 -> Some(200)
        3 -> Some(300)
        _ -> None
    }
}

// Pattern matching on Option - the core way to handle optionality
fn get_or_zero(id: Int) -> Int {
    case find_value(id) {
        Some(n) -> n
        None -> 0
    }
}

// Check if a value exists
fn value_exists(id: Int) -> Bool {
    case find_value(id) {
        Some(_) -> True
        None -> False
    }
}

// Double the value if it exists
fn double_if_present(id: Int) -> Option(Int) {
    case find_value(id) {
        Some(n) -> Some(n * 2)
        None -> None
    }
}

// Transform the value if it exists
fn add_bonus(id: Int, bonus: Int) -> Option(Int) {
    case find_value(id) {
        Some(n) -> Some(n + bonus)
        None -> None
    }
}

// Main demonstration
fn main() -> Nil {
    let val1 = find_value(1)              // Some(100)
    let val99 = find_value(99)            // None

    let result = get_or_zero(1)           // 100
    let missing = get_or_zero(99)         // 0

    let exists = value_exists(1)          // True
    let not_exists = value_exists(99)     // False

    let doubled = double_if_present(2)    // Some(400)

    Nil
}
