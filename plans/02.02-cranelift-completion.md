# Cranelift Compiler Completion Plan

**Status**: ðŸš§ **IN PROGRESS** - Active development  
**Parent Plan**: [02-compiler-implementation.md](02-compiler-implementation.md)  
**Prerequisites**: âœ… Handle-based Runtime, âœ… Cranelift Infrastructure  
**Estimated Timeline**: 5 weeks  
**Complexity**: Medium

## Overview

This plan provides a detailed roadmap for completing the Cranelift-based Tribute compiler. The infrastructure is already in place, and this plan focuses on implementing the remaining language features and optimizations needed for a production-ready compiler.

## Current Status Analysis

### âœ… Completed Infrastructure
- **tribute-cranelift crate**: Fully set up with Cranelift integration
- **Runtime function declarations**: All C ABI functions declared
- **HIR â†’ Cranelift IR pipeline**: Basic CodeGenerator and FunctionLowerer
- **Handle-based runtime**: DashMap optimization with AtomicU32 counters
- **Basic compilation**: Numbers, arithmetic, simple function calls working

### âœ… Phase 1 Completed Components
1. **TrString 3-mode system**: âœ… Enum-based inline/static/heap modes implemented
2. **Automatic mode selection**: âœ… Runtime chooses optimal storage based on string length
3. **Simplified C API**: âœ… Single function with automatic optimization
4. **Memory efficiency**: âœ… 15-byte strings use zero heap allocation
5. **Test coverage**: âœ… All modes tested with boundary conditions

### âŒ Critical Missing Components (Phase 2+)
1. **String constant table**: .rodata section string management missing
2. **Static string access**: Need compiler integration for .rodata base address
3. **String interpolation**: Complex interpolation compilation missing
4. **Pattern matching**: Match expressions not implemented
5. **Main function**: Top-level expression evaluation incomplete
6. **trbc integration**: Compiler binary not connected
7. **Linking pipeline**: Cannot generate executable binaries

## Core Innovation: TrString Enum-Based System

### Problem with Current Approach
Current TrString uses only heap allocation via AllocationTable, which is inefficient for:
- Short strings (heap allocation overhead)
- String literals (runtime allocation for compile-time constants)
- Memory usage (every string needs heap allocation)

### Solution: Three-Mode TrString Enum
```rust
#[repr(C)]
pub enum TrString {
    // Mode 1: Inline - strings â‰¤ 15 bytes stored directly
    Inline { 
        data: [u8; 15], 
        len: u8 
    },
    // Mode 2: Static - compile-time strings in object file
    Static { 
        offset: u32,     // Offset in .rodata section
        len: u32         // Use u32 for consistent 20-byte size
    },
    // Mode 3: Heap - runtime strings in AllocationTable
    Heap { 
        data_index: u32, // AllocationTable index
        len: u32         // Use u32 for consistent 20-byte size
    },
}
```

### Benefits
- **Memory efficiency**: 15-byte strings need no heap allocation
- **Performance**: Inline strings have zero indirection overhead
- **Binary size**: String literals stored efficiently in .rodata
- **Runtime speed**: Optimal path for each string type
- **Compact size**: Total enum size is only 20 bytes

## Implementation Plan (5 Weeks)

### Phase 1: TrString Enum System (1.5 weeks)

#### Week 1.0-1.5: Core TrString Implementation
1. **Enum Structure Design**
   ```rust
   // Ensure C ABI compatibility and 20-byte size
   #[repr(C)]
   pub enum TrString {
       Inline { data: [u8; 15], len: u8 },
       Static { offset: u32, len: u32 },
       Heap { data_index: u32, len: u32 },
   }
   ```

2. **Simplified Runtime Functions**
   - `tr_value_from_string(data: *const u8, len: usize) -> TrHandle`
     - Automatically chooses inline (â‰¤ 15 bytes) vs heap (> 15 bytes)
   - `tr_value_from_static_string(offset: u32, len: u32) -> TrHandle`
     - For compiler-generated string literals in .rodata section

3. **Automatic Mode Selection**
   ```rust
   // Runtime strings: automatically choose inline vs heap
   fn tr_value_from_string(data: *const u8, len: usize) -> TrHandle {
       // TrString::new() internally chooses:
       // - len <= 15: inline mode (no heap allocation)
       // - len > 15: heap mode (allocation table)
   }
   
   // Compile-time strings: use static mode
   fn tr_value_from_static_string(offset: u32, len: u32) -> TrHandle {
       // Points to string data in .rodata section
   }
   ```

4. **Testing**
   - Unit tests for all three modes
   - Memory layout verification
   - C ABI compatibility tests

### Phase 2: Cranelift String Constant Processing (1 week)

#### Week 2.0-3.0: Object File String Management
1. **String Constant Table**
   - Create `.rodata.strings` section in object file
   - Implement string deduplication
   - Generate offset mappings

2. **Cranelift Integration**
   ```rust
   struct StringConstantTable {
       strings: HashMap<String, u32>, // string -> offset
       data: Vec<u8>,                 // raw string data
   }
   
   impl CodeGenerator {
       fn add_string_constant(&mut self, text: &str) -> u32 {
           // Add to table, return offset
       }
   }
   ```

3. **Compiler String Literal Processing**
   - Short literals â†’ Inline mode generation
   - Long literals â†’ Static mode with offset
   - Runtime strings â†’ Heap mode calls

4. **String Interpolation Implementation**
   - Parse interpolation into static + dynamic parts
   - Generate efficient concatenation code
   - Use `tr_string_interpolate` runtime function

### Phase 3: Advanced Language Features (1 week)

#### Week 3.0-4.0: Pattern Matching and Control Flow
1. **Pattern Matching Compilation**
   ```rust
   // match expr { pattern => body, ... }
   // Compiled to:
   let temp = evaluate_expr();
   if pattern_matches(temp, pattern1) {
       goto body1;
   } else if pattern_matches(temp, pattern2) {
       goto body2;
   } else {
       goto default;
   }
   ```

2. **Control Flow Improvements**
   - Proper block scoping for let bindings
   - Variable lifetime management
   - Conditional jumps and block merging

3. **Main Function Implementation**
   - Evaluate top-level expressions in order
   - Return appropriate exit code
   - Handle program initialization

### Phase 4: Linking and Build System (1 week)

#### Week 4.0-5.0: Complete Build Pipeline
1. **trbc Binary Integration**
   ```rust
   // Add to main crate dependencies
   [dependencies]
   tribute-cranelift = { path = "crates/tribute-cranelift" }
   
   // Implement --compile mode
   if compile_mode {
       let object_bytes = compile_to_object(&db, hir_program, target)?;
       let executable = link_with_runtime(object_bytes, output_path)?;
   }
   ```

2. **Runtime Linking**
   - Link generated object with tribute-runtime static library
   - Resolve string constant table at runtime
   - Handle cross-platform linking (start with current platform)

3. **Build System Integration**
   - One-command compilation: `trbc --compile input.trb -o output`
   - Automatic runtime linking
   - Error handling and reporting

### Phase 5: Optimization and Testing (0.5 weeks)

#### Week 5.0-5.5: Polish and Validation
1. **Performance Optimization**
   - Benchmark each string mode
   - Profile memory usage patterns
   - Optimize compilation speed

2. **Comprehensive Testing**
   - Test all `lang-examples/*.trb` files
   - Compare interpreter vs compiler results
   - Stress test with large programs

3. **Documentation and Error Handling**
   - Clear compilation error messages
   - Performance measurement reports
   - Usage documentation

## Technical Specifications

### TrString Memory Layout
```
Total size: 20 bytes (optimized from 24)
Alignment: 4 bytes

Inline:  [discriminant:4][data:15][len:1]
Static:  [discriminant:4][offset:4][len:4][padding:8]
Heap:    [discriminant:4][index:4][len:4][padding:8]
```

### String Mode Selection Logic
```rust
fn select_string_mode(text: &str, context: StringContext) -> StringMode {
    match context {
        StringContext::Literal if text.len() <= 15 => StringMode::Inline,
        StringContext::Literal => StringMode::Static,
        StringContext::Runtime => StringMode::Heap,
        StringContext::Interpolation => {
            // Mix of static and heap based on segments
            StringMode::Mixed
        }
    }
}
```

### Object File String Section Format
```
.rodata.strings:
  header: [count: u32][total_size: u32]
  entries: [offset: u32, length: u32, data: [u8]]...
  
Example:
  [0x00000003][0x00000020]  // 3 strings, 32 bytes total
  [0x00000000][0x0000000B]["hello world\0"]
  [0x0000000C][0x00000007]["test\0\0\0"]
  [0x00000014][0x00000008]["goodbye\0"]
```

## Performance Targets

### Memory Efficiency
- **Inline strings**: 100% heap allocation savings (for strings â‰¤ 15 bytes)
- **Static strings**: 50% memory reduction (shared literals)
- **Overall**: 30-40% memory usage reduction

### Execution Speed
- **Short strings**: 5-10x faster access (no indirection)
- **String literals**: 2-3x faster (compile-time optimization)
- **Overall performance**: 3-5x faster than interpreter

### Compilation Speed
- **Small programs**: < 1 second compilation
- **Medium programs**: < 5 seconds compilation
- **Incremental**: Support for future incremental compilation

## Success Criteria

### Functional Completeness
1. **All language features work**: functions, let bindings, arithmetic, strings, pattern matching
2. **100% lang-examples coverage**: Every example file compiles and runs correctly
3. **Result consistency**: Compiled programs produce identical output to interpreter

### Performance Benchmarks
1. **Speed improvement**: Minimum 3x faster than interpreter for typical workloads
2. **Memory efficiency**: 30% reduction in runtime memory usage
3. **Binary size**: Reasonable executable sizes with string optimization

### Developer Experience
1. **Simple workflow**: `trbc --compile program.trb -o program && ./program`
2. **Clear errors**: Helpful compilation error messages with line numbers
3. **Fast turnaround**: Quick edit-compile-test cycles

## Risk Assessment and Mitigation

### Technical Risks

**Risk**: TrString enum C ABI compatibility
- **Likelihood**: Low
- **Impact**: High
- **Mitigation**: Extensive testing with C interop, use `#[repr(C)]` consistently

**Risk**: String constant table size explosion
- **Likelihood**: Medium
- **Impact**: Medium  
- **Mitigation**: String deduplication, compression for large literals

**Risk**: Cross-platform linking complexity
- **Likelihood**: High
- **Impact**: Medium
- **Mitigation**: Start with single platform, add others incrementally

### Schedule Risks

**Risk**: Pattern matching complexity underestimated
- **Likelihood**: Medium
- **Impact**: Medium
- **Mitigation**: Start with simple patterns, add complex ones later

**Risk**: Runtime linking issues
- **Likelihood**: Medium
- **Impact**: High
- **Mitigation**: Prototype linking early, have fallback to static linking

## Future Enhancements

### Post-Completion Improvements
1. **JIT compilation**: Use Cranelift's JIT capabilities for interactive use
2. **Advanced optimizations**: Dead code elimination, constant folding
3. **Debug information**: DWARF generation for better debugging
4. **Incremental compilation**: Cache compiled modules for faster rebuilds

### Integration Opportunities
1. **WebAssembly target**: Cranelift supports WASM compilation
2. **Plugin system**: Allow runtime loading of compiled modules
3. **Profiling integration**: Built-in performance monitoring

## Conclusion

This plan provides a clear path to completing the Cranelift-based Tribute compiler. The focus on TrString optimization addresses a key performance bottleneck while maintaining the existing handle-based architecture. The 5-week timeline is realistic given the existing infrastructure and the targeted approach to string handling.

The enum-based TrString system is the key innovation that will differentiate this implementation, providing significant performance benefits while maintaining compatibility with the existing runtime system.