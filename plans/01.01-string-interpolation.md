# String Interpolation Implementation Plan

> **Status**: ✅ **COMPLETED** (syntax design done, implementation proceeds with compiler development)

## Overview

Implementation plan for string interpolation in the Tribute language using `\{expr}` syntax to embed expressions within strings.

## Syntax Design

> Reference: `new-plans/syntax.md`

```
StringInterpolation ::= '\{' Expression '}'   // Expression must be String type
```

### Examples

```rust
let name = "Alice"
let age = 30

// Basic interpolation
"Hello, \{name}!"                    // "Hello, Alice!"

// Expression interpolation
"You are \{Int::to_string(age)} years old."

// Complex expressions
let x = 10
let y = 20
"\{Int::to_string(x)} + \{Int::to_string(y)} = \{Int::to_string(x + y)}"
// "10 + 20 = 30"
```

### String Literal Types

| Type | Syntax | Interpolation |
|------|--------|---------------|
| Regular string | `"..."` | ✅ Supported |
| Raw string | `r"..."` | ❌ Not supported |
| Multiline | `#"..."#` | ✅ Supported |
| Raw multiline | `r#"..."#` | ❌ Not supported |

### Escape Sequences

- `\\` - Backslash
- `\n`, `\r`, `\t` - Control characters
- `\{` - Literal `{` (prevents interpolation)
- `\}` - Literal `}`

## Implementation Steps

### 1. Grammar Updates (tree-sitter-tribute)

```javascript
// grammar.js
string_interpolation: $ => seq(
  '\\{',
  $.expression,
  '}'
),

string_content: $ => choice(
  $.escape_sequence,
  $.string_interpolation,
  /[^"\\]+/
),
```

### 2. TrunkIR Representation

String interpolation is lowered to `adt.string_const` and string concatenation operations:

```
// "\{a} + \{b}"
// ↓ lowering
%s1 = adt.string_const ""
%s2 = func.call @String::to_string(%a)
%s3 = adt.string_const " + "
%s4 = func.call @String::to_string(%b)
%result = func.call @String::concat(%s1, %s2, %s3, %s4)
```

### 3. Type Checking

- Interpolated expressions must be of type `String`
- Other types require explicit `to_string` call
- Type error: `"Value: \{42}"` → `Int` is not `String`

### 4. Codegen

Target-specific implementation:
- **Cranelift**: Runtime `String::concat` function call
- **WasmGC**: Use `stringref` concatenation operations

## Test Plan

### Unit Tests

```rust
test "basic interpolation" {
    let x = "world"
    assert_eq("Hello, \{x}!", "Hello, world!")
}

test "expression interpolation" {
    let n = 42
    assert_eq("Value: \{Int::to_string(n)}", "Value: 42")
}

test "escape sequences" {
    assert_eq("Literal: \\{not interpolated}", "Literal: {not interpolated}")
}

test "empty string parts" {
    let s = "test"
    assert_eq("\{s}", "test")
}
```

### Error Cases

1. Type mismatch: `"\{42}"` - `Int` is not `String`
2. Unclosed interpolation: `"\{expr`
3. Invalid expression: `"\{1 +}"`

## Design Decisions

### Q: Support format specifiers?

**Decision**: Not supported in initial version. Use explicit formatting functions instead.

```rust
// Use explicit formatting functions instead
"\{Float::format(pi, 2)}"  // "3.14"
```

### Q: Automatic to_string conversion?

**Decision**: Not supported. Explicit conversion required.

Rationale:
- Maintains type safety
- Avoids complex systems like `Show` trait
- Expresses clear intent

### Q: Nil value handling?

**Decision**: `Nil::to_string` returns `"Nil"`.

## Related Documents

- `new-plans/syntax.md` - Full syntax definition
- `new-plans/types.md` - String type definition
