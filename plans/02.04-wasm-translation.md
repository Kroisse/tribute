# Wasm Translation Plan (TrunkIR -> Wasm)

Goal: compile Tribute end-to-end to WebAssembly (including WasmGC) by lowering TrunkIR into the `wasm` dialect and emitting a valid Wasm module, with runnable tests.

This plan tracks remaining work after the initial `wasm` dialect emitter and basic control-flow tests.

## 1) Dialect Coverage

### Module Items
- Add missing module-level ops and emitter support:
  - `wasm.table`, `wasm.elem` (function tables / indirect calls)
  - `wasm.global` / `wasm.global_get` / `wasm.global_set`
  - Optional: `wasm.tag` / exception ops if used for abilities
- Decide on default exports policy vs explicit exports only.

### Instructions
- Fill out remaining numeric ops and conversions used by lowering passes.
- Implement `memory` ops: `load`, `store`, `memory.grow`, `memory.size`.
- Add `call_indirect` support in emitter and tests.
- Validate multi-value results for block/loop/if (if needed by lowering).

### Types
- Define mapping from TrunkIR types to Wasm value types:
  - Integers/floats, `ptr`/`ref` types.
  - WasmGC refs (`externref`, `anyref`, `eqref`, `structref`) as needed.
- Clarify how `core.nil` maps to “no result”.

## 2) Lowering Passes to `wasm` Dialect

### Entry Lowering
- `func.func`/`func.call` → `wasm.func`/`wasm.call` model (if a distinct op is needed).
- Map block args and local variables to Wasm locals.
- Ensure return paths match Wasm stack discipline.

### Structured Control Flow
- `scf.if`/`scf.while`/`scf.for` → `wasm.if`/`wasm.loop` + `wasm.br_if`.
- `cont` / continuation-based control flow to Wasm blocks.

### Data and Memory
- Lower string/bytes literals to `wasm.data` and memory offsets.
- Define memory layout rules for records/ADTs (or keep as a later phase).

### Indirect Calls and Closures
- Lower closures to function + environment and add `wasm.table`/`call_indirect`.

## 3) Runtime and ABI

- Define Wasm ABI conventions: entrypoint (`main`) and return values.
- WASI integration path (basic `fd_write`, environment, exit codes).
- Memory layout and allocator story (bump allocator as a minimal start).
- Plan for WasmGC usage (GC-managed refs, struct/array types, and interaction with abilities).
- Decide on the minimal WasmGC feature set required to avoid a custom GC.

## 4) Tests and Validation

- Expand unit tests for emitter coverage (block/loop results, br depths, call_indirect).
- Add TrunkIR-to-wasm integration tests (build module, run with wasmtime).
- Add end-to-end `.trb` → TrunkIR → Wasm tests (small programs).

## 5) Tooling and Pipeline

- Add pipeline stage to lower to wasm dialect (where it fits after TDNr).
- CLI target flag (`--target wasm` or similar) wiring.
- Document env vars for test runner (e.g. `TRIBUTE_WASMTIME`).

## Open Questions

- Which WasmGC proposal subset is the baseline (structs/arrays/typed function refs)?
- How soon do we lock memory layout for ADTs and strings?
- Do we want explicit export ops only, or auto-export `main`?
