# Implementation Gaps vs. Design (2025-12-19)

This note summarizes the gaps identified between the authoritative design docs in `new-plans/` and the current implementation. Each item includes the intended behavior, current behavior, and the main impact.

## 1) Module system and `use` resolution [DONE]

- Design expectation: `use` imports populate the name resolution scope; qualified paths are fully resolved; file-based modules map to files/directories.
- Current state: `use_declaration` is ignored in lowering, and resolver imports are never populated. Qualified path resolution only uses the last segment. File-based modules are marked TODO.
- Impact: Name resolution diverges from spec; UFCS/type-directed resolution has an incomplete search space; module layout from `modules.md` is not implementable yet.

## 2) Effect annotations in function types (->{E})

- Design expectation: Function types and definitions carry effect rows (`fn(a) ->{E} b`) with `{}` for pure and row variables for polymorphism.
- Current state: Parsing/lowering always builds `core.func` without effect rows (no `core::Func::with_effect` usage). Lambdas also use `core::Func::new`.
- Impact: Ability/effect info is lost at the type level, preventing correct effect inference, checking, and propagation.

## 3) Ability calls lowering (Ability::op -> ability.perform)

- Design expectation: Ability operations are performed via `ability.perform` and handled via `ability.prompt` + `case`.
- Current state: Ability calls are lowered as `src.call` (same as ordinary calls). `ability.perform` is defined in IR but not produced by lowering.
- Impact: Effect tracking for abilities cannot be sound, and ability-specific lowering to `cont` is blocked.

## 4) Effect typing propagation and unification

- Design expectation: `func.call` should propagate the callee's effect row; solver should unify function effects using effect rows.
- Current state: `func.call` always merges a fresh row variable (ignoring any declared effect). Solver has TODO for unifying function effect rows.
- Impact: Effect inference is largely disconnected from actual calls, which blocks meaningful effect checking and error reporting.

## 5) Ability type parameters in effect rows

- Design expectation: Effect rows treat `State(Int)` and `State(String)` as distinct abilities and allow both when parameters differ.
- Current state: `AbilityRef` ordering compares only by name, which risks treating different parameterizations as duplicates. `ability.perform` checking ignores ability type parameters.
- Impact: Duplicate detection and row unification can reject valid programs or accept invalid ones.

## 6) UFCS and field access

- Design expectation: `x.f(y)` is UFCS; zero-arg calls allow `x.f`; struct fields are getters in the same namespace.
- Current state: No `src.dot_call` op (design doc mentions it). Method calls are lowered to `src.call` with only a bare name. TDNR registry is empty, so no methods are resolved. Field getters are not auto-generated.
- Impact: UFCS works only if a globally-resolved function name happens to match. Field access in the spec (`user.name`) cannot be resolved.

## 7) Record spread/update and enum named fields

- Design expectation: Record update syntax (`User { ..user, age: 31 }`) and enum variants with named fields are supported.
- Current state: Record construction exists but no spread/update lowering. Enum named fields exist in syntax docs but lowering treats fields as positional.
- Impact: Surface syntax in `types.md` is only partially usable; migration examples will fail.

## 8) String/bytes literal prefixes and interpolation variants

- Design expectation: Prefixed string/bytes forms (`s"..."`, `r"..."`, `sr"..."`, `rs"..."`, etc.) are supported as specified.
- Current state: Literal parsing handles only a subset (raw vs non-raw) and does not recognize the full prefix combinations in `syntax.md`.
- Impact: Examples using `s` and `sr/rs` forms will not parse or decode as specified.

## 9) `const` usage and resolution

- Design expectation: `const` values are defined and resolved/inlined at use sites.
- Current state: `src.const` ops are created, but resolver does not resolve or inline them during name resolution.
- Impact: `const` definitions exist in IR but are unusable in code, diverging from the spec.
