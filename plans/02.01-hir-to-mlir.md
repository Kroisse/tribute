# HIR to MLIR Lowering Implementation Plan

**Status**: ðŸš§ **IN PROGRESS** - Core infrastructure completed  
**Prerequisites**: âœ… Modern Syntax (Plan 01), âœ… String Interpolation (Plan 01.01)  
**Estimated Timeline**: 2-3 weeks  
**Complexity**: Medium  
**Next Step**: ðŸ“‹ MLIR Interpreter (Plan 02.02)

## Overview

This plan implements translation from Tribute's HIR (High-level Intermediate Representation) to a custom MLIR dialect, maintaining the existing AST â†’ HIR â†’ MLIR pipeline. This approach leverages the existing HIR infrastructure while enabling both MLIR interpretation (02.02) and native compilation (02).

### Strategic Goals

1. **HIR Translation**: Convert HIR expressions to MLIR operations
2. **Dialect Foundation**: Define complete Tribute MLIR dialect using melior 0.25.0
3. **Type Preservation**: Maintain dynamic type information in MLIR
4. **Debug Information**: Preserve source location mapping
5. **Salsa Integration**: Implement incremental compilation through Salsa queries
6. **Dual Pathway**: Support both HIR evaluation and MLIR-based execution

## Architecture Overview

### Current vs Target

**Previous Flow:**
```
Source â†’ AST â†’ HIR â†’ HIR Evaluator
```

**New Flow (Implemented):**
```
Source â†’ AST â†’ HIR â†’ MLIR Dialect â†’ MLIR Evaluator/Interpreter
```

**Salsa Query Integration:**
```
Source â†’ AST (Salsa) â†’ HIR (Salsa) â†’ MLIR (Salsa) â†’ Evaluation
```

### Tribute MLIR Dialect

The dialect represents Tribute's dynamic operations in MLIR's type-safe framework:

```mlir
// Example lowered MLIR
module {
  tribute.func @add(%arg0: !tribute.value, %arg1: !tribute.value) -> !tribute.value {
    %0 = tribute.add %arg0, %arg1 : !tribute.value
    tribute.return %0 : !tribute.value
  }
  
  tribute.func @main() -> !tribute.value {
    %0 = tribute.constant 5.0 : f64
    %1 = tribute.constant 3.0 : f64  
    %2 = tribute.to_runtime %0 : f64 -> !tribute.value
    %3 = tribute.to_runtime %1 : f64 -> !tribute.value
    %4 = tribute.call @add(%2, %3) : (!tribute.value, !tribute.value) -> !tribute.value
    tribute.return %4 : !tribute.value
  }
}
```

## Implementation Plan

### Week 1: Dialect Definition âœ… **COMPLETED**

**Goal**: Define complete Tribute dialect using melior 0.25.0 (Cargo-only approach)

#### Core Types (Rust Implementation)
```rust
// crates/tribute-hir-dialect/src/types.rs
impl<'c> TributeTypes<'c> {
    /// Get the dynamic `!tribute.value` type
    pub fn value_type(&self) -> Type<'c> {
        // Using i64 as placeholder for dynamic value representation
        IntegerType::new(self.context, 64).into()
    }

    /// Get the string type
    pub fn string_type(&self) -> Type<'c> {
        IntegerType::new(self.context, 8).into()
    }

    /// Get the f64 type for numeric constants
    pub fn f64_type(&self) -> Type<'c> {
        IntegerType::new(self.context, 64).into()
    }
}
```

#### Core Operations (Rust Implementation)
```rust
// crates/tribute-hir-dialect/src/ops.rs
impl<'c> TributeOps<'c> {
    /// Create a constant operation for f64 values
    pub fn constant_f64(&self, value: f64, location: Location<'c>) -> Result<Operation<'c>, LoweringError> {
        let f64_type = self.types.f64_type();
        let attr = FloatAttribute::new(self.context, f64_type, value).into();
        
        OperationBuilder::new("arith.constant", location)
            .add_attributes(&[(Identifier::new(self.context, "value"), attr)])
            .add_results(&[f64_type])
            .build()
    }

    /// Create an addition operation
    pub fn add(&self, lhs: Value<'c, '_>, rhs: Value<'c, '_>, location: Location<'c>) -> Result<Operation<'c>, LoweringError> {
        let result_type = self.types.value_type();
        
        OperationBuilder::new("tribute.add", location)
            .add_operands(&[lhs, rhs])
            .add_results(&[result_type])
            .build()
    }
}
```

**Deliverables** âœ…:
- âœ… Complete Rust-based dialect definition using melior 0.25.0
- âœ… Core type system (tribute.value, tribute.string, etc.)
- âœ… Basic operations (constant, add, sub, mul, div, call, return)
- âœ… Cargo-only build integration (no CMake required)
- âœ… Basic operation verification via unit tests

### Week 2: Lowering Infrastructure âœ… **COMPLETED**

**Goal**: Implement HIR â†’ MLIR conversion framework with Salsa integration

#### Lowering Context (Implemented)
```rust
// crates/tribute-hir-dialect/src/hir_lowering.rs
pub struct HirToMLIRLowerer<'c> {
    context: &'c Context,
    dialect: TributeDialect<'c>,
    ops: TributeOps<'c>,
    module: Module<'c>,
    
    // Symbol tables
    function_symbols: HashMap<String, Operation<'c>>,
    value_map: HashMap<String, Value<'c, 'c>>,
}

impl<'c> HirToMLIRLowerer<'c> {
    pub fn new(context: &'c Context) -> Self {
        let dialect = TributeDialect::new(context);
        let ops = TributeOps::new(context);
        let location = Location::unknown(context);
        let module = Module::new(location);
        
        Self {
            context,
            dialect,
            ops,
            module,
            function_symbols: HashMap::new(),
            value_map: HashMap::new(),
        }
    }
    
    pub fn lower_hir_program<'db>(&mut self, db: &'db dyn HirDatabase, program: HirProgram<'db>) -> Result<&Module<'c>, LoweringError> {
        // First pass: declare all functions
        for function in program.functions(db) {
            self.declare_hir_function(db, function)?;
        }
        
        // Second pass: implement function bodies
        for function in program.functions(db) {
            self.implement_hir_function(db, function)?;
        }
        
        Ok(&self.module)
    }
}
```

#### HIR Expression Lowering (Implemented)
```rust
impl<'c> HirToMLIRLowerer<'c> {
    fn lower_hir_expression<'db>(&mut self, db: &'db dyn HirDatabase, expr: HirExpr<'db>) -> Result<Value<'c, 'c>, LoweringError> {
        let location = self.dialect.unknown_location();
        
        match expr.kind(db) {
            HirExprKind::Number(n) => {
                // Create f64 constant, then convert to runtime value
                let const_op = self.ops.constant_f64(*n, location)?;
                let const_value = const_op.result(0)?.into();
                let runtime_op = self.ops.to_runtime(const_value, location)?;
                Ok(runtime_op.result(0)?.into())
            }
            
            HirExprKind::String(s) => {
                let const_op = self.ops.constant_string(s, location)?;
                Ok(const_op.result(0)?.into())
            }
            
            HirExprKind::StringInterpolation(segments) => {
                // Handle string interpolation with segment concatenation
                let mut result_value = None;
                for segment in segments {
                    let segment_value = match segment {
                        StringSegment::Text(text) => {
                            let const_op = self.ops.constant_string(text, location)?;
                            const_op.result(0)?.into()
                        }
                        StringSegment::Expression(hir_expr) => {
                            self.lower_hir_expression(db, *hir_expr)?
                        }
                    };
                    
                    result_value = Some(match result_value {
                        None => segment_value,
                        Some(current) => {
                            let concat_op = self.ops.string_concat(current, segment_value, location)?;
                            concat_op.result(0)?.into()
                        }
                    });
                }
                Ok(result_value.unwrap())
            }
            
            HirExprKind::Binary { operator, left, right } => {
                let lhs = self.lower_hir_expression(db, *left)?;
                let rhs = self.lower_hir_expression(db, *right)?;
                
                let result_op = match operator {
                    BinaryOperator::Add => self.ops.add(lhs, rhs, location)?,
                    BinaryOperator::Subtract => self.ops.sub(lhs, rhs, location)?,
                    BinaryOperator::Multiply => self.ops.mul(lhs, rhs, location)?,
                    BinaryOperator::Divide => self.ops.div(lhs, rhs, location)?,
                };
                
                Ok(result_op.result(0)?.into())
            }
            
            HirExprKind::Call { function, arguments } => {
                let arg_values: Result<Vec<_>, _> = arguments
                    .iter()
                    .map(|arg| self.lower_hir_expression(db, *arg))
                    .collect();
                
                let call_op = self.ops.call(function, &arg_values?, location)?;
                Ok(call_op.result(0)?.into())
            }
            
            HirExprKind::Variable(name) => {
                self.value_map.get(name).copied()
                    .ok_or_else(|| LoweringError::SymbolTableError(format!("Variable not found: {}", name)))
            }
            
            _ => Err(LoweringError::UnsupportedExpression(expr.kind(db).clone())),
        }
    }
}
```

**Deliverables** âœ…:
- âœ… HIR expression lowering (numbers, strings, binary ops, calls, variables)
- âœ… String interpolation with segment concatenation
- âœ… Symbol table management framework
- âœ… Source location preservation infrastructure  
- âœ… Comprehensive error handling and diagnostics (LoweringError, EvaluationError)
- âœ… MLIR-based evaluator with runtime values (TributeValue)
- âœ… Salsa integration for incremental compilation

### Week 2.5: Salsa Integration âœ… **COMPLETED**

**Goal**: Implement incremental compilation through Salsa queries for MLIR lowering

#### Salsa Query System (Implemented)
```rust
// crates/tribute-hir-dialect/src/salsa_integration.rs

/// Salsa query to lower HIR program to MLIR
#[salsa::tracked]
pub fn lower_hir_to_mlir(
    db: &dyn HirDatabase,
    program: HirProgram,
) -> Result<MLIRModule, LoweringError> {
    let context = MLIRContext::new();
    let mut lowerer = HirToMLIRLowerer::new(&context);
    
    let module = lowerer.lower_hir_program(db, program)?;
    Ok(MLIRModule::new(context, module.clone()))
}

/// Salsa query to evaluate MLIR using the evaluator
#[salsa::tracked]
pub fn evaluate_mlir(
    db: &dyn HirDatabase,
    mlir_module: MLIRModule,
) -> Result<TributeValue, EvaluationError> {
    let evaluator = MLIREvaluator::new();
    evaluator.evaluate_module(&mlir_module.module)
}

/// Combined query for complete HIR -> MLIR -> Evaluation pipeline
#[salsa::tracked]
pub fn hir_to_mlir_eval(
    db: &dyn HirDatabase,
    program: HirProgram,
) -> Result<TributeValue, Box<dyn std::error::Error>> {
    let mlir_module = lower_hir_to_mlir(db, program)?;
    let result = evaluate_mlir(db, mlir_module)?;
    Ok(result)
}
```

#### Incremental Compilation Benefits
- **Cached Lowering**: MLIR is regenerated only when HIR changes
- **Selective Recompilation**: Only modified functions are re-lowered
- **Query Composition**: Easy integration with existing HIR queries
- **Debug Support**: Intermediate MLIR can be inspected and cached

**Deliverables** âœ…:
- âœ… Salsa-tracked MLIR lowering queries
- âœ… Incremental compilation infrastructure
- âœ… MLIRModule wrapper for Salsa integration
- âœ… Combined HIR â†’ MLIR â†’ Evaluation pipeline
- âœ… Query composition with existing HIR system

### Week 3: Integration & Testing ðŸš§ **IN PROGRESS**

**Goal**: Complete integration with existing toolchain and remaining features

#### API Integration
```rust
// src/lib.rs - Extended API with Salsa integration

/// Main API for HIR to MLIR lowering (uses Salsa queries)
pub fn lower_hir_to_mlir_cached(
    db: &dyn HirDatabase, 
    program: HirProgram
) -> Result<MLIRModule, LoweringError> {
    // Uses Salsa query for incremental compilation
    tribute_hir_dialect::salsa_integration::lower_hir_to_mlir(db, program)
}

/// Complete evaluation pipeline: HIR â†’ MLIR â†’ Result
pub fn eval_hir_via_mlir(
    db: &dyn HirDatabase,
    program: HirProgram
) -> Result<TributeValue, Box<dyn std::error::Error>> {
    tribute_hir_dialect::salsa_integration::hir_to_mlir_eval(db, program)
}

/// Development/debugging helper - convert source to MLIR string
pub fn compile_to_mlir_string(
    db: &dyn TributeDatabase, 
    filename: &str, 
    input: &str
) -> Result<String, Box<dyn std::error::Error>> {
    let (program, _) = parse_str(db, filename, input);
    let hir_program = lower_ast_to_hir(db, program);
    let mlir_module = lower_hir_to_mlir_cached(db, hir_program)?;
    
    Ok(mlir_module.to_string())
}
```

#### Testing Framework
```rust
// tests/hir_to_mlir.rs
#[test]
fn test_simple_arithmetic() {
    let db = TributeDatabaseImpl::default();
    let input = "1 + 2 * 3";
    
    let mlir = compile_to_mlir_string(&db, "test.trb", input).unwrap();
    
    // Verify structure
    assert!(mlir.contains("tribute.constant 1.0"));
    assert!(mlir.contains("tribute.constant 2.0"));  
    assert!(mlir.contains("tribute.constant 3.0"));
    assert!(mlir.contains("tribute.mul"));
    assert!(mlir.contains("tribute.add"));
}

#[test]
fn test_function_definition() {
    let db = TributeDatabaseImpl::default();
    let input = r#"
        fn add(a, b) {
            a + b
        }
        add(5, 3)
    "#;
    
    let mlir = compile_to_mlir_string(&db, "test.trb", input).unwrap();
    
    assert!(mlir.contains("tribute.func @add"));
    assert!(mlir.contains("tribute.call @add"));
    assert!(mlir.contains("tribute.return"));
}

#[test]
fn test_string_interpolation() {
    let db = TributeDatabaseImpl::default();
    let input = r#"let name = "world"; "Hello, \{name}!""#;
    
    let mlir = compile_to_mlir_string(&db, "test.trb", input).unwrap();
    
    assert!(mlir.contains("tribute.string_interpolation"));
}
```

**Deliverables**:
- Complete test suite
- Performance benchmarking
- Documentation and examples
- Integration with existing CLI tools

## Technical Specifications

### HIR to MLIR Operation Mapping

| HIR Expression | MLIR Operations | Notes |
|----------------|-----------------|--------|
| `HirExprKind::Number(n)` | `arith.constant` â†’ `tribute.to_runtime` | Convert static to dynamic |
| `HirExprKind::String(s)` | `tribute.constant` | Direct string constant |
| `HirExprKind::StringInterpolation(segments)` | `tribute.string_concat` sequence | Segment concatenation |
| `HirExprKind::Binary{Add, l, r}` | `tribute.add` | Dynamic addition |
| `HirExprKind::Call{function, arguments}` | `tribute.call` | Function invocation |
| `HirExprKind::Variable(name)` | SSA value lookup | Variable reference |
| `HirExprKind::Let{bindings, body}` | Multiple ops + `scf.execute_region` | Local scope |
| `HirExprKind::If{cond, then, else}` | `tribute.to_bool` â†’ `scf.if` | Conditional |
| `HirExprKind::Match{expr, cases}` | `tribute.match` | Pattern matching |

### Type Strategy

**Dynamic Foundation**: Start with `!tribute.value` for all expressions
```mlir
%0 = tribute.constant 42.0 : f64
%1 = tribute.to_runtime %0 : f64 -> !tribute.value
```

**Future Optimization**: Add type inference to generate specialized paths
```mlir
%0 = arith.constant 42.0 : f64        // Known type
%1 = arith.constant 3.0 : f64         // Known type  
%2 = arith.addf %0, %1 : f64          // Optimized operation
%3 = tribute.to_runtime %2 : f64 -> !tribute.value  // Interface boundary
```

### Error Handling

```rust
#[derive(Debug, thiserror::Error)]
pub enum LoweringError {
    #[error("Unsupported HIR expression: {0:?}")]
    UnsupportedExpression(HirExprKind),
    
    #[error("Unsupported AST expression: {0}")]
    UnsupportedAst(String),
    
    #[error("Function not found: {0}")]
    FunctionNotFound(String),
    
    #[error("Symbol table error: {0}")]
    SymbolTableError(String),
    
    #[error("Invalid MLIR generated")]
    InvalidMLIR,
    
    #[error("MLIR operation creation failed: {0}")]
    OperationCreationFailed(String),
    
    #[error("Type error: {0}")]
    TypeError(String),
    
    #[error("FFI error: {0}")]
    FFIError(String),
}
```

## Build Integration âœ… **COMPLETED**

### Cargo-Only Build (No CMake Required)
```toml
# crates/tribute-hir-dialect/Cargo.toml
[package]
name = "tribute-hir-dialect"
version = "0.1.0"
edition = "2021"

[dependencies]
melior = "0.25.0"
tribute-ast = { path = "../tribute-ast" }
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }

[build-dependencies]
# For future C++ glue code if needed
cc = "1.0"

[dev-dependencies]
insta = "1.34"
```

### Workspace Integration
```toml
# Root Cargo.toml (updated)
[workspace]
members = [
    "crates/tree-sitter-tribute",
    "crates/tribute-ast", 
    "crates/tribute-hir",        # Maintained for existing HIR infrastructure
    "crates/tribute-hir-dialect", # New MLIR-based implementation
]
```

## Success Criteria

### Functional Requirements
- âœ… All core AST expressions have MLIR equivalents (numbers, strings, binary ops, calls)
- âœ… Generated MLIR passes basic verification
- âœ… Source location infrastructure preserved
- âœ… Function declaration and call framework implemented
- ðŸš§ Pattern matching translation (planned for next phase)
- ðŸš§ Control flow operations (if/match with scf integration)

### Quality Requirements  
- âœ… Comprehensive test coverage with unit and integration tests
- âœ… Clear error messages for unsupported features (LoweringError types)
- âœ… HIR-to-MLIR approach leverages existing infrastructure
- âœ… Generated MLIR uses standard dialects (arith, tribute)
- âœ… String interpolation with proper segment handling
- âœ… Complete evaluator with runtime value system
- âœ… Salsa integration for incremental compilation

### Integration Requirements
- ðŸš§ Integration with existing CLI tools (in progress)
- ðŸš§ API compatibility updates needed
- âœ… Ready for Plan 02.02 (MLIR Interpreter) - foundation complete
- âœ… Supports future optimization passes via MLIR infrastructure

## Risk Mitigation

### Technical Risks
- **MLIR Learning Curve**: Start with simple operations, build complexity gradually
- **FFI Complexity**: Use proven patterns from melior examples
- **Performance Regression**: Benchmark against HIR at each step

### Project Risks  
- **Scope Creep**: Focus only on translation, defer optimization
- **Integration Issues**: Maintain HIR path as fallback during development
- **Timeline Pressure**: Prioritize core operations, defer advanced features

## Current Implementation Status

### âœ… **Completed (Week 1-2.5)**
- **Core Infrastructure**: Complete tribute-hir-dialect crate with melior 0.25.0
- **Type System**: Dynamic tribute.value, string, and numeric types  
- **Basic Operations**: Arithmetic operations (add, sub, mul, div) and constants
- **Function Framework**: Function declaration, calls, and returns
- **Lowering Pipeline**: HIR â†’ MLIR translation with both direct AST and HIR paths
- **String Interpolation**: Full segment concatenation support in MLIR
- **Evaluator**: MLIR-based runtime with comprehensive TributeValue system
- **Salsa Integration**: Incremental compilation queries for MLIR lowering
- **Testing**: Comprehensive test suite covering dialect, types, operations, evaluation, and integration
- **Build System**: Cargo-only approach (no CMake dependency)
- **Error Handling**: Complete LoweringError and EvaluationError systems

### ðŸš§ **Next Phase (Week 3+)**
- Control flow operations (if/match with SCF dialect)
- Let bindings with scoped symbol tables
- Pattern matching MLIR operations
- Integration tests for full ASTâ†’HIRâ†’MLIRâ†’Evaluation pipeline
- Main API updates to use MLIR as primary execution path
- CLI tool integration with --emit-mlir flag
- Performance optimization passes

### ðŸŽ¯ **Key Achievement**
Successfully implemented comprehensive HIR-to-MLIR lowering with Salsa integration, maintaining the existing HIR infrastructure while adding MLIR capabilities. The dual-path approach (ASTâ†’MLIR and HIRâ†’MLIR) provides flexibility and the Salsa integration enables incremental compilation. String interpolation with segment concatenation and a complete evaluator system are fully functional. The foundation is now ready for both interpretation (Plan 02.02) and native compilation (Plan 02).