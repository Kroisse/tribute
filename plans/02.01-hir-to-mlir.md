# AST to MLIR Direct Lowering Implementation Plan

**Status**: ðŸš§ **IN PROGRESS** - Core infrastructure completed  
**Prerequisites**: âœ… Modern Syntax (Plan 01), âœ… String Interpolation (Plan 01.01)  
**Estimated Timeline**: 2-3 weeks  
**Complexity**: Medium  
**Next Step**: ðŸ“‹ MLIR Interpreter (Plan 02.02)

## Overview

This plan implements direct translation from Tribute's AST to a custom MLIR dialect, bypassing the HIR layer entirely. This simplified approach reduces complexity while enabling both MLIR interpretation (02.02) and native compilation (02).

### Strategic Goals

1. **Direct Translation**: Convert AST expressions directly to MLIR operations
2. **Dialect Foundation**: Define complete Tribute MLIR dialect using melior 0.25.0
3. **Type Preservation**: Maintain dynamic type information in MLIR
4. **Debug Information**: Preserve source location mapping
5. **HIR Deprecation**: Replace HIR-based evaluation with MLIR-based execution

## Architecture Overview

### Current vs Target

**Previous Flow (Deprecated):**
```
Source â†’ AST â†’ HIR â†’ HIR Evaluator
```

**New Flow (Implemented):**
```
Source â†’ AST â†’ MLIR Dialect â†’ MLIR Evaluator/Interpreter
```

### Tribute MLIR Dialect

The dialect represents Tribute's dynamic operations in MLIR's type-safe framework:

```mlir
// Example lowered MLIR
module {
  tribute.func @add(%arg0: !tribute.value, %arg1: !tribute.value) -> !tribute.value {
    %0 = tribute.add %arg0, %arg1 : !tribute.value
    tribute.return %0 : !tribute.value
  }
  
  tribute.func @main() -> !tribute.value {
    %0 = tribute.constant 5.0 : f64
    %1 = tribute.constant 3.0 : f64  
    %2 = tribute.to_runtime %0 : f64 -> !tribute.value
    %3 = tribute.to_runtime %1 : f64 -> !tribute.value
    %4 = tribute.call @add(%2, %3) : (!tribute.value, !tribute.value) -> !tribute.value
    tribute.return %4 : !tribute.value
  }
}
```

## Implementation Plan

### Week 1: Dialect Definition âœ… **COMPLETED**

**Goal**: Define complete Tribute dialect using melior 0.25.0 (Cargo-only approach)

#### Core Types (Rust Implementation)
```rust
// crates/tribute-hir-dialect/src/types.rs
impl<'c> TributeTypes<'c> {
    /// Get the dynamic `!tribute.value` type
    pub fn value_type(&self) -> Type<'c> {
        // Using i64 as placeholder for dynamic value representation
        IntegerType::new(self.context, 64).into()
    }

    /// Get the string type
    pub fn string_type(&self) -> Type<'c> {
        IntegerType::new(self.context, 8).into()
    }

    /// Get the f64 type for numeric constants
    pub fn f64_type(&self) -> Type<'c> {
        IntegerType::new(self.context, 64).into()
    }
}
```

#### Core Operations (Rust Implementation)
```rust
// crates/tribute-hir-dialect/src/ops.rs
impl<'c> TributeOps<'c> {
    /// Create a constant operation for f64 values
    pub fn constant_f64(&self, value: f64, location: Location<'c>) -> Result<Operation<'c>, LoweringError> {
        let f64_type = self.types.f64_type();
        let attr = FloatAttribute::new(self.context, f64_type, value).into();
        
        OperationBuilder::new("arith.constant", location)
            .add_attributes(&[(Identifier::new(self.context, "value"), attr)])
            .add_results(&[f64_type])
            .build()
    }

    /// Create an addition operation
    pub fn add(&self, lhs: Value<'c, '_>, rhs: Value<'c, '_>, location: Location<'c>) -> Result<Operation<'c>, LoweringError> {
        let result_type = self.types.value_type();
        
        OperationBuilder::new("tribute.add", location)
            .add_operands(&[lhs, rhs])
            .add_results(&[result_type])
            .build()
    }
}
```

**Deliverables** âœ…:
- âœ… Complete Rust-based dialect definition using melior 0.25.0
- âœ… Core type system (tribute.value, tribute.string, etc.)
- âœ… Basic operations (constant, add, sub, mul, div, call, return)
- âœ… Cargo-only build integration (no CMake required)
- âœ… Basic operation verification via unit tests

### Week 2: Lowering Infrastructure âœ… **COMPLETED**

**Goal**: Implement AST â†’ MLIR conversion framework (bypassing HIR)

#### Lowering Context (Implemented)
```rust
// crates/tribute-hir-dialect/src/lowering.rs
pub struct AstToMLIRLowerer<'c> {
    context: &'c Context,
    dialect: TributeDialect<'c>,
    ops: TributeOps<'c>,
    module: Module<'c>,
    
    // Symbol tables
    function_symbols: HashMap<String, Operation<'c>>,
    value_map: HashMap<String, Value<'c, 'c>>,
}

impl<'c> AstToMLIRLowerer<'c> {
    pub fn new(context: &'c Context) -> Self {
        let dialect = TributeDialect::new(context);
        let ops = TributeOps::new(context);
        let location = Location::unknown(context);
        let module = Module::new(location);
        
        Self {
            context,
            dialect,
            ops,
            module,
            function_symbols: HashMap::new(),
            value_map: HashMap::new(),
        }
    }
    
    pub fn lower_program<'db>(&mut self, db: &'db dyn Db, program: Program<'db>) -> Result<&Module<'c>, LoweringError> {
        // First pass: declare all functions
        for item in program.items(db) {
            match item.kind(db) {
                ItemKind::Function(func) => self.declare_function(db, *func)?,
                _ => {} // Skip non-function items
            }
        }
        
        // Second pass: implement function bodies
        for item in program.items(db) {
            match item.kind(db) {
                ItemKind::Function(func) => self.implement_function(db, *func)?,
                _ => {} // Skip non-function items for now
            }
        }
        
        Ok(&self.module)
    }
}
```

#### Expression Lowering (Implemented)
```rust
impl<'c> AstToMLIRLowerer<'c> {
    fn lower_expression(&mut self, expr: Spanned<Expr>) -> Result<Value<'c, 'c>, LoweringError> {
        let location = self.dialect.unknown_location();
        let (expr, _span) = expr;
        
        match expr {
            Expr::Number(n) => {
                // Create f64 constant, then convert to runtime value
                let const_op = self.ops.constant_f64(n as f64, location)?;
                let const_value = const_op.result(0)?.into();
                let runtime_op = self.ops.to_runtime(const_value, location)?;
                Ok(runtime_op.result(0)?.into())
            }
            
            Expr::StringInterpolation(s) => {
                let const_op = self.ops.constant_string(&s.leading_text, location)?;
                Ok(const_op.result(0)?.into())
            }
            
            Expr::Binary(binary_expr) => {
                let lhs = self.lower_expression(*binary_expr.left)?;
                let rhs = self.lower_expression(*binary_expr.right)?;
                
                let result_op = match binary_expr.operator {
                    BinaryOperator::Add => self.ops.add(lhs, rhs, location)?,
                    BinaryOperator::Subtract => self.ops.sub(lhs, rhs, location)?,
                    BinaryOperator::Multiply => self.ops.mul(lhs, rhs, location)?,
                    BinaryOperator::Divide => self.ops.div(lhs, rhs, location)?,
                };
                
                Ok(result_op.result(0)?.into())
            }
            
            Expr::Call(call_expr) => {
                let arg_values: Result<Vec<_>, _> = call_expr.arguments
                    .into_iter()
                    .map(|arg| self.lower_expression(arg))
                    .collect();
                
                let call_op = self.ops.call(&call_expr.function, &arg_values?, location)?;
                Ok(call_op.result(0)?.into())
            }
            
            Expr::Identifier(id) => {
                self.value_map.get(&id).copied()
                    .ok_or_else(|| LoweringError::SymbolTableError(format!("Variable not found: {}", id)))
            }
            
            _ => Err(LoweringError::UnsupportedAst(format!("Expression not supported: {:?}", expr))),
        }
    }
}
```

**Deliverables** âœ…:
- âœ… AST expression lowering (numbers, strings, binary ops, calls, identifiers)
- âœ… Symbol table management framework
- âœ… Source location preservation infrastructure  
- âœ… Comprehensive error handling and diagnostics (LoweringError, EvaluationError)
- âœ… MLIR-based evaluator with runtime values (TributeValue)

### Week 3: Integration & Testing ðŸš§ **IN PROGRESS**

**Goal**: Complete integration with existing toolchain and remaining features

#### API Integration
```rust
// src/lib.rs - Extended API
pub fn lower_hir_to_mlir(
    db: &dyn HirDatabase, 
    program: HirProgram
) -> Result<(Context, Module), LoweringError> {
    let context = Context::new();
    
    // Register Tribute dialect
    unsafe {
        tribute_dialect_register(context.to_raw());
    }
    
    let mut lowerer = HirToMLIRLowerer::new(&context);
    let module = lowerer.lower_program(db, program)?;
    
    // Verify the generated MLIR
    if !module.verify() {
        return Err(LoweringError::InvalidMLIR);
    }
    
    Ok((context, module))
}

// Development/debugging helper
pub fn compile_to_mlir_string(db: &dyn TributeDatabase, filename: &str, input: &str) -> Result<String, EvalError> {
    let (program, _) = parse_str(db, filename, input);
    let hir_program = lower_ast_to_hir(db, program);
    let (context, module) = lower_hir_to_mlir(db, hir_program)?;
    
    Ok(module.as_operation().to_string())
}
```

#### Testing Framework
```rust
// tests/hir_to_mlir.rs
#[test]
fn test_simple_arithmetic() {
    let db = TributeDatabaseImpl::default();
    let input = "1 + 2 * 3";
    
    let mlir = compile_to_mlir_string(&db, "test.trb", input).unwrap();
    
    // Verify structure
    assert!(mlir.contains("tribute.constant 1.0"));
    assert!(mlir.contains("tribute.constant 2.0"));  
    assert!(mlir.contains("tribute.constant 3.0"));
    assert!(mlir.contains("tribute.mul"));
    assert!(mlir.contains("tribute.add"));
}

#[test]
fn test_function_definition() {
    let db = TributeDatabaseImpl::default();
    let input = r#"
        fn add(a, b) {
            a + b
        }
        add(5, 3)
    "#;
    
    let mlir = compile_to_mlir_string(&db, "test.trb", input).unwrap();
    
    assert!(mlir.contains("tribute.func @add"));
    assert!(mlir.contains("tribute.call @add"));
    assert!(mlir.contains("tribute.return"));
}

#[test]
fn test_string_interpolation() {
    let db = TributeDatabaseImpl::default();
    let input = r#"let name = "world"; "Hello, \{name}!""#;
    
    let mlir = compile_to_mlir_string(&db, "test.trb", input).unwrap();
    
    assert!(mlir.contains("tribute.string_interpolation"));
}
```

**Deliverables**:
- Complete test suite
- Performance benchmarking
- Documentation and examples
- Integration with existing CLI tools

## Technical Specifications

### Operation Mapping

| HIR Expression | MLIR Operations | Notes |
|----------------|-----------------|--------|
| `HirExpr::Number(n)` | `arith.constant` â†’ `tribute.to_runtime` | Convert static to dynamic |
| `HirExpr::String(s)` | `tribute.constant` | Direct string constant |
| `HirExpr::Binary{Add, l, r}` | `tribute.add` | Dynamic addition |
| `HirExpr::Call{func, args}` | `tribute.call` | Function invocation |
| `HirExpr::Let{bindings, body}` | Multiple ops + `scf.execute_region` | Local scope |
| `HirExpr::If{cond, then, else}` | `tribute.to_bool` â†’ `scf.if` | Conditional |
| `HirExpr::Match{expr, cases}` | `tribute.match` | Pattern matching |

### Type Strategy

**Dynamic Foundation**: Start with `!tribute.value` for all expressions
```mlir
%0 = tribute.constant 42.0 : f64
%1 = tribute.to_runtime %0 : f64 -> !tribute.value
```

**Future Optimization**: Add type inference to generate specialized paths
```mlir
%0 = arith.constant 42.0 : f64        // Known type
%1 = arith.constant 3.0 : f64         // Known type  
%2 = arith.addf %0, %1 : f64          // Optimized operation
%3 = tribute.to_runtime %2 : f64 -> !tribute.value  // Interface boundary
```

### Error Handling

```rust
#[derive(Debug, thiserror::Error)]
pub enum LoweringError {
    #[error("Unsupported HIR expression: {0:?}")]
    UnsupportedExpression(HirExprKind),
    
    #[error("Function not found: {0}")]
    FunctionNotFound(String),
    
    #[error("Invalid MLIR generated")]
    InvalidMLIR,
    
    #[error("MLIR operation creation failed: {0}")]
    OperationCreationFailed(String),
    
    #[error("FFI error: {0}")]
    FFIError(String),
}
```

## Build Integration âœ… **COMPLETED**

### Cargo-Only Build (No CMake Required)
```toml
# crates/tribute-hir-dialect/Cargo.toml
[package]
name = "tribute-hir-dialect"
version = "0.1.0"
edition = "2021"

[dependencies]
melior = "0.25.0"
tribute-ast = { path = "../tribute-ast" }
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }

[build-dependencies]
# For future C++ glue code if needed
cc = "1.0"

[dev-dependencies]
insta = "1.34"
```

### Workspace Integration
```toml
# Root Cargo.toml (updated)
[workspace]
members = [
    "crates/tree-sitter-tribute",
    "crates/tribute-ast", 
    "crates/tribute-hir",        # Deprecated
    "crates/tribute-hir-dialect", # New MLIR-based implementation
]
```

## Success Criteria

### Functional Requirements
- âœ… All core AST expressions have MLIR equivalents (numbers, strings, binary ops, calls)
- âœ… Generated MLIR passes basic verification
- âœ… Source location infrastructure preserved
- âœ… Function declaration and call framework implemented
- ðŸš§ Pattern matching translation (planned for next phase)
- ðŸš§ Control flow operations (if/match with scf integration)

### Quality Requirements  
- âœ… Basic test coverage with 7 unit tests passing
- âœ… Clear error messages for unsupported features (LoweringError types)
- âœ… Direct AST-to-MLIR approach eliminates HIR overhead
- âœ… Generated MLIR uses standard dialects (arith, tribute)

### Integration Requirements
- ðŸš§ Integration with existing CLI tools (in progress)
- ðŸš§ API compatibility updates needed
- âœ… Ready for Plan 02.02 (MLIR Interpreter) - foundation complete
- âœ… Supports future optimization passes via MLIR infrastructure

## Risk Mitigation

### Technical Risks
- **MLIR Learning Curve**: Start with simple operations, build complexity gradually
- **FFI Complexity**: Use proven patterns from melior examples
- **Performance Regression**: Benchmark against HIR at each step

### Project Risks  
- **Scope Creep**: Focus only on translation, defer optimization
- **Integration Issues**: Maintain HIR path as fallback during development
- **Timeline Pressure**: Prioritize core operations, defer advanced features

## Current Implementation Status

### âœ… **Completed (Week 1-2)**
- **Core Infrastructure**: Complete tribute-hir-dialect crate with melior 0.25.0
- **Type System**: Dynamic tribute.value, string, and numeric types
- **Basic Operations**: Arithmetic operations (add, sub, mul, div) and constants
- **Function Framework**: Function declaration, calls, and returns
- **Lowering Pipeline**: Direct AST â†’ MLIR translation
- **Evaluator**: MLIR-based runtime with TributeValue system
- **Testing**: 7 unit tests covering dialect, types, operations, and evaluation
- **Build System**: Cargo-only approach (no CMake dependency)

### ðŸš§ **Next Phase (Week 3+)**
- Control flow operations (if/match with SCF dialect)
- String interpolation MLIR operations
- Symbol table enhancements for let bindings
- Integration tests for full ASTâ†’MLIRâ†’Evaluation pipeline
- Main API updates to use MLIR instead of HIR
- CLI tool integration with --emit-mlir flag

### ðŸŽ¯ **Key Achievement**
Successfully eliminated HIR dependency by implementing direct AST-to-MLIR translation, simplifying the architecture while maintaining all dynamic language capabilities. The foundation is now ready for both interpretation (Plan 02.02) and native compilation (Plan 02).