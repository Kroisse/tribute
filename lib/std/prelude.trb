// Tribute Standard Library - Prelude
// These types are automatically available in all Tribute programs.

/// A type that represents an optional value.
/// Either contains `Some(value)` or `None`.
enum Option(a) {
    None,
    Some(a),
}

pub mod Option {
    /// Transform the value inside an Option using a function.
    /// If the Option is None, returns None.
    pub fn map(opt: Option(a), f: fn(a) -> b) -> Option(b) {
        case opt {
            Some(x) -> Some(f(x))
            None -> None
        }
    }

    /// Chain Option-returning operations.
    /// If the Option is None, returns None without calling f.
    pub fn and_then(opt: Option(a), f: fn(a) -> Option(b)) -> Option(b) {
        case opt {
            Some(x) -> f(x)
            None -> None
        }
    }

    /// Extract the value from an Option, or return a default.
    pub fn unwrap_or(opt: Option(a), default: a) -> a {
        case opt {
            Some(x) -> x
            None -> default
        }
    }

    /// Check if an Option contains a value.
    pub fn is_some(opt: Option(a)) -> Bool {
        case opt {
            Some(_) -> True
            None -> False
        }
    }

    /// Check if an Option is None.
    pub fn is_none(opt: Option(a)) -> Bool {
        case opt {
            Some(_) -> False
            None -> True
        }
    }
}

/// A type that represents either success (`Ok`) or failure (`Error`).
/// Used for operations that may fail.
enum Result(a, e) {
    Ok(a),
    Error(e),
}

/// UTF-8 rope structure for efficient string operations.
/// Strings are represented as a tree of byte sequences for efficient
/// concatenation and substring operations.
enum String {
    /// Leaf node containing UTF-8 bytes
    Leaf(Bytes),
    /// Branch node with left subtree, right subtree, cached byte length, and depth
    Branch(String, String, Int, Int),
}

pub mod String {
    /// Create an empty string
    pub fn empty() -> String {
        Leaf(Bytes::empty())
    }

    /// Create a string from bytes (assumes valid UTF-8)
    pub fn from_bytes(bytes: Bytes) -> String {
        Leaf(bytes)
    }

    /// Get the byte length of a string
    pub fn len(s: String) -> Int {
        case s {
            Leaf(bytes) -> Bytes::len(bytes)
            Branch(_, _, cached_len, _) -> cached_len
        }
    }

    /// Get the depth of the string tree
    pub fn depth(s: String) -> Int {
        case s {
            Leaf(_) -> 0
            Branch(_, _, _, d) -> d
        }
    }

    /// Concatenate two strings
    pub fn concat(left: String, right: String) -> String {
        let left_len = String::len(left)
        let right_len = String::len(right)
        let left_depth = String::depth(left)
        let right_depth = String::depth(right)
        let max_depth = if left_depth > right_depth { left_depth } else { right_depth }
        Branch(left, right, left_len + right_len, max_depth + 1)
    }

    /// Concatenation operator for strings
    pub fn (<>)(left: String, right: String) -> String {
        String::concat(left, right)
    }

    /// Convert a string to a byte sequence (flattens the rope)
    pub fn to_bytes(s: String) -> Bytes {
        case s {
            Leaf(bytes) -> bytes
            Branch(left, right, _, _) ->
                Bytes::concat(String::to_bytes(left), String::to_bytes(right))
        }
    }
}

pub mod Result {
    /// Transform the success value inside a Result using a function.
    /// If the Result is Error, returns the error unchanged.
    pub fn map(res: Result(a, e), f: fn(a) -> b) -> Result(b, e) {
        case res {
            Ok(x) -> Ok(f(x))
            Error(e) -> Error(e)
        }
    }

    /// Transform the error value inside a Result using a function.
    /// If the Result is Ok, returns the success value unchanged.
    pub fn map_err(res: Result(a, e), f: fn(e) -> f) -> Result(a, f) {
        case res {
            Ok(x) -> Ok(x)
            Error(e) -> Error(f(e))
        }
    }

    /// Chain Result-returning operations.
    /// If the Result is Error, returns the error without calling f.
    pub fn and_then(res: Result(a, e), f: fn(a) -> Result(b, e)) -> Result(b, e) {
        case res {
            Ok(x) -> f(x)
            Error(e) -> Error(e)
        }
    }

    /// Extract the success value from a Result, or return a default.
    pub fn unwrap_or(res: Result(a, e), default: a) -> a {
        case res {
            Ok(x) -> x
            Error(_) -> default
        }
    }

    /// Check if a Result is Ok.
    pub fn is_ok(res: Result(a, e)) -> Bool {
        case res {
            Ok(_) -> True
            Error(_) -> False
        }
    }

    /// Check if a Result is Error.
    pub fn is_error(res: Result(a, e)) -> Bool {
        case res {
            Ok(_) -> False
            Error(_) -> True
        }
    }
}

// =============================================================================
// Intrinsic declarations
// =============================================================================
// These functions are implemented by the backend (e.g., wasm).
// The `__` prefix marks them as internal/reserved.

extern "intrinsic" fn __bytes_len(bytes: Bytes) -> Int
extern "intrinsic" fn __bytes_get_or_panic(bytes: Bytes, index: Int) -> Int
extern "intrinsic" fn __bytes_slice_or_panic(bytes: Bytes, start: Int, end: Int) -> Bytes
extern "intrinsic" fn __bytes_concat(left: Bytes, right: Bytes) -> Bytes
extern "intrinsic" fn __bytes_empty() -> Bytes
extern "intrinsic" fn __print_bytes(bytes: Bytes) -> Nil
extern "intrinsic" fn __print_newline() -> Nil

// =============================================================================
// Bytes module
// =============================================================================

/// Bytes module with operations for byte sequences.
pub mod Bytes {
    /// Create an empty byte sequence.
    pub fn empty() -> Bytes {
        __bytes_empty()
    }

    /// Get the length of a byte sequence.
    pub fn len(bytes: Bytes) -> Int {
        __bytes_len(bytes)
    }

    /// Get the byte at the given index.
    /// Panics if index is out of bounds.
    pub fn get_or_panic(bytes: Bytes, index: Int) -> Int {
        __bytes_get_or_panic(bytes, index)
    }

    /// Create a slice of the byte sequence.
    /// Panics if start or end is out of bounds.
    pub fn slice_or_panic(bytes: Bytes, start: Int, end: Int) -> Bytes {
        __bytes_slice_or_panic(bytes, start, end)
    }

    /// Concatenate two byte sequences.
    pub fn concat(left: Bytes, right: Bytes) -> Bytes {
        __bytes_concat(left, right)
    }

    /// Concatenation operator for byte sequences.
    pub fn (<>)(left: Bytes, right: Bytes) -> Bytes {
        left.concat(right)
    }

    /// Get the byte at the given index.
    /// Returns None if index is out of bounds.
    pub fn get(bytes: Bytes, index: Int) -> Option(Int) {
        if index >= 0 && index < bytes.len() {
            Some(bytes.get_or_panic(index))
        } else {
            None
        }
    }

    /// Create a slice of the byte sequence.
    /// Clamps start and end to valid bounds.
    pub fn slice(bytes: Bytes, start: Int, end: Int) -> Bytes {
        let len = bytes.len()
        let s = if start < 0 { 0 } else if start > len { len } else { start }
        let e = if end < s { s } else if end > len { len } else { end }
        bytes.slice_or_panic(s, e)
    }
}

// =============================================================================
// I/O functions
// =============================================================================

/// Print bytes to standard output (without newline).
pub fn print_bytes(bytes: Bytes) -> Nil {
    __print_bytes(bytes)
}

/// Print a line to standard output (with newline).
/// NOTE: Currently simplified - only prints newline.
/// Full String printing requires case expression support.
pub fn print_line(message: String) -> Nil {
    // TODO: Implement full String printing when case expressions work
    // For now, just print a newline
    __print_newline()
}
