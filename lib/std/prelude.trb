// Tribute Standard Library - Prelude
// These types are automatically available in all Tribute programs.

/// A type that represents an optional value.
/// Either contains `Some(value)` or `None`.
enum Option(a) {
    None,
    Some(a),
}

pub mod Option {
    /// Transform the value inside an Option using a function.
    /// If the Option is None, returns None.
    pub fn map(opt: Option(a), f: fn(a) -> b) -> Option(b) {
        case opt {
            Some(x) -> Some(f(x))
            None -> None
        }
    }

    /// Chain Option-returning operations.
    /// If the Option is None, returns None without calling f.
    pub fn and_then(opt: Option(a), f: fn(a) -> Option(b)) -> Option(b) {
        case opt {
            Some(x) -> f(x)
            None -> None
        }
    }

    /// Extract the value from an Option, or return a default.
    pub fn unwrap_or(opt: Option(a), default: a) -> a {
        case opt {
            Some(x) -> x
            None -> default
        }
    }

    /// Check if an Option contains a value.
    pub fn is_some(opt: Option(a)) -> Bool {
        case opt {
            Some(_) -> True
            None -> False
        }
    }

    /// Check if an Option is None.
    pub fn is_none(opt: Option(a)) -> Bool {
        case opt {
            Some(_) -> False
            None -> True
        }
    }
}

/// A type that represents either success (`Ok`) or failure (`Error`).
/// Used for operations that may fail.
enum Result(a, e) {
    Ok(a),
    Error(e),
}

pub mod Result {
    /// Transform the success value inside a Result using a function.
    /// If the Result is Error, returns the error unchanged.
    pub fn map(res: Result(a, e), f: fn(a) -> b) -> Result(b, e) {
        case res {
            Ok(x) -> Ok(f(x))
            Error(e) -> Error(e)
        }
    }

    /// Transform the error value inside a Result using a function.
    /// If the Result is Ok, returns the success value unchanged.
    pub fn map_err(res: Result(a, e), f: fn(e) -> f) -> Result(a, f) {
        case res {
            Ok(x) -> Ok(x)
            Error(e) -> Error(f(e))
        }
    }

    /// Chain Result-returning operations.
    /// If the Result is Error, returns the error without calling f.
    pub fn and_then(res: Result(a, e), f: fn(a) -> Result(b, e)) -> Result(b, e) {
        case res {
            Ok(x) -> f(x)
            Error(e) -> Error(e)
        }
    }

    /// Extract the success value from a Result, or return a default.
    pub fn unwrap_or(res: Result(a, e), default: a) -> a {
        case res {
            Ok(x) -> x
            Error(_) -> default
        }
    }

    /// Check if a Result is Ok.
    pub fn is_ok(res: Result(a, e)) -> Bool {
        case res {
            Ok(_) -> True
            Error(_) -> False
        }
    }

    /// Check if a Result is Error.
    pub fn is_error(res: Result(a, e)) -> Bool {
        case res {
            Ok(_) -> False
            Error(_) -> True
        }
    }
}

// =============================================================================
// Intrinsic declarations
// =============================================================================
// These functions are implemented by the backend (e.g., wasm).
// The `__` prefix marks them as internal/reserved.

extern "intrinsic" fn __bytes_len(bytes: Bytes) -> Int
extern "intrinsic" fn __bytes_get_or_panic(bytes: Bytes, index: Int) -> Int
extern "intrinsic" fn __bytes_slice_or_panic(bytes: Bytes, start: Int, end: Int) -> Bytes
extern "intrinsic" fn __bytes_concat(left: Bytes, right: Bytes) -> Bytes
extern "intrinsic" fn __print_line(message: String) -> Nil

// =============================================================================
// Bytes module
// =============================================================================

/// Bytes module with operations for byte sequences.
pub mod Bytes {
    /// Get the length of a byte sequence.
    pub fn len(bytes: Bytes) -> Int {
        __bytes_len(bytes)
    }

    /// Get the byte at the given index.
    /// Panics if index is out of bounds.
    pub fn get_or_panic(bytes: Bytes, index: Int) -> Int {
        __bytes_get_or_panic(bytes, index)
    }

    /// Create a slice of the byte sequence.
    /// Panics if start or end is out of bounds.
    pub fn slice_or_panic(bytes: Bytes, start: Int, end: Int) -> Bytes {
        __bytes_slice_or_panic(bytes, start, end)
    }

    /// Concatenate two byte sequences.
    pub fn concat(left: Bytes, right: Bytes) -> Bytes {
        __bytes_concat(left, right)
    }

    /// Concatenation operator for byte sequences.
    pub fn (<>)(left: Bytes, right: Bytes) -> Bytes {
        left.concat(right)
    }

    /// Get the byte at the given index.
    /// Returns None if index is out of bounds.
    pub fn get(bytes: Bytes, index: Int) -> Option(Int) {
        case index >= 0 && index < bytes.len() {
            True -> Some(bytes.get_or_panic(index))
            False -> None
        }
    }

    /// Create a slice of the byte sequence.
    /// Clamps start and end to valid bounds.
    pub fn slice(bytes: Bytes, start: Int, end: Int) -> Bytes {
        let len = bytes.len()
        let s = case start < 0 {
            True -> 0
            False -> case start > len {
                True -> len
                False -> start
            }
        }
        let e = case end < s {
            True -> s
            False -> case end > len {
                True -> len
                False -> end
            }
        }
        bytes.slice_or_panic(s, e)
    }
}

// =============================================================================
// I/O functions
// =============================================================================

/// Print a line to standard output.
fn print_line(message: String) -> Nil {
    __print_line(message)
}
